---
title: "설계의 본질"
date: 2026-02-03
update: 2026-02-03
tags:
  - 설계
  - loopers
---

## 들어가며

loopers Round1 을 진행하며 고민한 흔적을 남깁니다.  

정신을 차리고 보니, 어느새 코드보다. 설계에 더 많은 시간을 쏟게 되는것 같습니다.

> 자연스럽게 설계의 본질이 무었인지 회고해보았습니다.

## 설계의 본질에 대해서

> 코드는 변경을 감당하기 위한 계약 이다.  
> 설계는 변경 비용을 어디에 지불할지 정하는 일이다.

우리는 항상 비용을 지불한다.

- 신규 입사자 진입장벽 을 낮추기 위한 노력은, **이해 비용**을 줄이는 선택이고.
- 확장성 을 높이자니, **미래 변경 비용**을 줄이는 선택을 하게된다.
- 생산성 을 높이려면, **현재 구현 비용**을 줄이는 선택 (대신 미래에 비용 증가가 발생한다.)

그러다 결론을 내렸다.
설계는 “아름다움”혹은 "깎는 영역" 이라기 보단
**비용 을 어느 상황에 지불할지에 대한 판단** 으로.

> 정답이랄 께 없지만, 조직에 소속되어 일을 하다보면.
> 그 상황에 맞는 설계가 존재하고, 트레이드 오프를 제안할 수 있게된다.
> 
> 적절한 판단은 역시, 직접 부딪혀보는 경험치가 있어야한다.
---

##  Round1 현재 환경에서 매몰 비용을 치루게 된 사연

- Redis 있지
- Kafka 있지
- TPS 모르지
- 그러다보니,서비스 규모 예상안되지
- 도메인 복잡도 모르지
    
일부러 모호한 환경에서의 기획의도일까... 그럴 가능성이 높다고 본다..

> 그래서 너무 좋은 기회인것 같다.
> "불확실한 환경에서 설계 판단 연습" 이랄까.
> 항상 들어간 회사는 이미 시작된 서비스 였고, 
> 그러다 보니. 극 초기 의 상황을 몰랐다.

스스로 겪어온 회사에서의 상황은 통상 아래와 같았다.
- 평상시 TPS 50~300
- 특정 시간대 5배 튀는 날 존재 할수도, 안할수도 있으며,
- 요구사항은 계속 바뀐다


> 그리고 또다시 결론을 내렸다.
> 
> **좋은 땅을 가정하지 않는다.**

---

## 의존성 방향에 대해서, 왜 이렇게 가져가는가?

현재 의존성 구조

- interfaces -> application -> domain
- infrastructure -> domain

지켜야 할 의존 방향

- 의존성은 항상 안쪽(도메인)을 향한다
- 도메인은 외부 기술에 의존하지 않는다

사실, 처음엔 왜 이렇게 되었을까 라고 생각하기보단.  
외우기 바빴다.  

생각을 정리하니, **복잡성을 효율적으로 관리하기 위해 세워진 전략** 중 하나인것으로 보아야할것으로 보인다.

> 그러면, 앞서 말한 **여러 전략중 하나** 가 있듯이.
> 복잡성도 여러 종류가 있을까 ?

---

## 복잡성도 두 종류

1. **본질적 복잡성** — 비즈니스 규칙
2. **우발적 복잡성** — 프레임워크, DB, 네트워크

우발적 복잡성을 바깥으로 밀어내고  
본질적 복잡성만 중앙에 남기는 방식이 헥사고날 방식이였다.

변경에 취약한 것이,
안정적인 것에 의존해야 한다는 점이다.

그래야 변경이 전파되지 않는다고 생각한다.

> 어느순간 이걸 왜 고민하게 되었지 ? 라는 질문은 자연스레 해소되었다.  
> 결론적으로, 일을 효율적으로 하기 위해서는 여러방식이 있다고 생각한다.
> 
> 그런데 아직 가려운 부분은 해소가 안되었다.  
> 
> 개발의 생태계는 프레임별로 간단하다면 간단하게,  
> 어렵다면 무진장 어렵게 생각 할 수 있다.  
> 
> 그래서 보통 저마다의 상황이 있어, 더 나은 선택을 위함이지.  
> 이게 정답입니다 ! 라고 함부로 말하기 어려운 영역인것 같다.  
> 
> 그럼 내 상황에서, 생각해보자.  
> 
> 코드레벨, 구조   
> 
> 누굴 위해서지 ?  

---

## 누굴 위한 코드인가?

지금까지의 경험으로는, 우리는 비용을 어디에 두는가? 
부터 시작했었다.

- 도메인 보호 중심 설계의 경우, 본질적 복잡성을 보호하기 위해서요.
    
- 유스케이스 흐름 중심 설계의 경우, 실행 흐름을 제어하기 위해서요.
    
지금은 AI 시대에 살고있고, 흐름 구현은 AI가 잘한다.

그런데, 경계 정의와 복잡성 관리 전략은 사람이 한다.

> AI 가 구현을 더 잘해. 그런데 통제는 해야해 저마다의 상황과 조직별,
> 은탄환을 위해서지, 수학적으로 접근할 수 없다.
> 
> 하... 그럼 어디에나 던져놔도 살릴수 있는 설계는 없을까 ? 
---

## “어디에 던져놔도 살릴 수 있는 설계” 란 무엇인가?

사이드 프로젝트, 토이프로젝트 지금껏 왜 망했었나 ?
규모를 가정하고 정답처럼 생각했다.

> 빅테크의 상황을 가정하지 않는다.
> 대신 진흙뻘에서도 무너지지 않는 구조를 만든다.

그 조건은 다음과 같다고 본다.

- 도메인은 기술에 오염되지 않는다.
- 트랜잭션 경계는 UseCase에 있다.
- 외부 시스템(Redis, Kafka)은 Port 뒤에 둔다.
- 처음부터 이벤트를 쓰지 않는다.
- 하지만 이벤트를 못 쓰게 만들지도 않는다.

> 미리 나누지 않되, 대신 나눌 수 없게 만들지 않는다.
> 
> 이게 어려운 영역이고 "킥" 이라면 킥인가 생각이 들 정도이다.
> 
> 그럼 어느때 설계가 무너지고 버그가 투성인 코드로 자라게 될까 ?
> 애초에 접근이 틀린것일지도 모른다.

---

## 설계 위반 vs 버그

- 버그는 테스트가 잡는다.    
- 설계 위반의 경우, 테스트가 못 잡을 수 있다.
- 설계 위반은 “나쁜 관습”을 퍼뜨린다.
- 그 관습은 미래 변경 비용을 폭발시킨다.

다시 정리하면, 설계 위반은 지금 당장 고장 나지 않는다.

다만.. "미래의 버그 확률을 구조적으로 증가시키는 행위" 로 생각했다.

강제 수준은 다음과 같이 표현해볼 수 있을것 같다.

| 수준  | 방법              | 강제력    |
| --- | --------------- | ------ |
| 0   | 없음              | 없음     |
| 1   | 주석              | 약함     |
| 2   | 코드 리뷰           | 약함     |
| 3   | ArchUnit        | 테스트 타임 |
| 4   | 멀티모듈 + internal | 컴파일 타임 |

가능하면 3 이상으로 끌어올린다.

> 그럼 처음으로 돌아와서, Round1 인 지금시점에.
> 처음 고민이였던, 복합적인 고민은.
> 
> 지금 당장 분리해야하나 ? 에 대해서 답을 내릴수 있을것 같다.

---

## 지금 당장 분리해야 하는가?

Nope.

하지만 다음 신호가 오면 분리한다

- 기능 하나 변경에 파일 n개 수정
- 설명 비용 > 구현 비용
- 테스트가 도메인이 아니라 JPA를 검증
- 트랜잭션 경계가 도메인에 스며듦

복잡도는 크기가 아니라  
**변경 비용의 증가 패턴**으로 판단할래요.

---

## 설계 철학

감성 커머스 시스템은 다음을 우선한다.

1. 본질적 복잡성(비즈니스 규칙)을 보호한다.
2. 변경 비용이 전파되지 않도록 의존성을 설계한다.
3. 설계 위반은 자동화된 강제로 조기에 차단한다.
4. 기술 선택은 늦추되, 기술을 수용할 경계는 미리 만든다.

---

## 결론

설계의 본질은 이것이라고 생각합니다.

> 시스템이 10배 커져도  
> 핵심 비즈니스 규칙을 바꾸지 않고 확장할 수 있는가?

아름다움을 위해 깎는 설계는 위험하다.  
구조를 위해 비용을 배치하는 설계는 살아남는다.

우리는 나주평야를 가정하지 않는다.  
진흙뻘에서도 성을 쌓을 수 있어야 한다.