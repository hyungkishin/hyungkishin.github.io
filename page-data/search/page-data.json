{"componentChunkName":"component---src-pages-search-jsx","path":"/search/","result":{"data":{"allMarkdownRemark":{"nodes":[{"excerpt":"아이스 브레이킹 22 년 어느날, Back-end 개발자로 개발생활을 영위하며 바쁜 일상생활을 보내고 있었던 🍁가을무렵 이였다. 헤성처럼 나타나 개발자들에게 \"코더 계속 하실 ?\" 이라는 극딜을 준 G 선생. 솔직히 처음 모델만 해도 리펙토링 정도만 살짝 참고하는 정도여서 전혀 히지 않았다. 분명 그랬을 터인데, 24년 여름쯤 이였다. 일정 테트리스로 인…","fields":{"slug":"/spring-ai/"},"frontmatter":{"date":"March 29, 2025","title":"Ai. Spring AI 로 때워도 되나유? 1편","tags":["AI","Spring"]},"rawMarkdownBody":"\n## 아이스 브레이킹\n\n22 년 어느날, Back-end 개발자로 개발생활을 영위하며 바쁜 일상생활을 보내고 있었던 🍁가을무렵 이였다. 헤성처럼 나타나 개발자들에게 *\"코더 계속 하실 ?\"* 이라는 극딜을 준 G 선생. 솔직히 처음 모델만 해도 리펙토링 정도만 살짝 참고하는 정도여서 전혀 `긁`히지 않았다. 분명 그랬을 터인데, 24년 여름쯤 이였다. 일정 테트리스로 인하여 여러 프로젝트가 겹쳐 시간이 빠듯하였고 결국 생성형 AI 를 적극 활용하기로 하였다. 그 결과 무려 10배 혹은 20배나 되는 `생산성의 맛` 을 봐 버렸고. 요망한 AI 에게 의존하는 삶을 살게 되었다.\n![ㅎ...형!!!](image-2.png)\n\n의존 하다보니 느끼는 감정은 날것 그대로 쓰기엔 오류도 많고 아직 사람손이 타야하는 영역이 많긴한데, 점점 그 빈도가 **줄어들고 있다는 점**에서 불안과 걱정의 씨앗이 심어졌다. 정말 어느 순간 모르게 급격하게 발전해서 **\"비즈니스 영역까지 커버하게 된다면\"** 더이상 내 자신이 회사에 필요하지 않게될 날이 도래하겠다는 생각이 들었다. \"에이 ~ AI 는 아직 부족한 부분이 많으니 대체되지 않을거야\" 라는 **미련을 빨리 버려야 된다**고 생각했다. 그러나 처음부터 AI 의 모든 영역을 공부하기엔 현실적으로 많은 러닝커브가 따르고 막막하여 생각에 잠긴다.\n\n> 1️⃣ Web 개발자 관점에서 AI 를 활용하기 위해 어떤 개념들을 알아야 할까 🤔 ? <br/>\n> 2️⃣ Spring AI 가 있다는데, python 없이도 AI 기술들을 커버할 수 있는걸까 🤔 ? <br/>\n> 3️⃣ 많이 뒤쳐진것 같아 불안해. 빠르게 AI 기술들을 적용해보고 싶어 ‼️ <br/>\n\n## 돈워리. Web 개발자 관점에서 요구되는 AI 기술 부터\n웹 개발자는 AI 모델을 직접 연구하거나 신경망을 설계하는 사람이 아니다. **AI를 활용하여 제품을 개발하고 사용자 경험을 향상시키는 데 초점**을 맞추어야 한다. 단, 요구되는 지식은 다음과 같다.\n\n- **AI 기술 이해**: ( 머신러닝 딥러닝 기본 개념 ), AI 모델 작동 방식\n- **API 및 라이브러리 활용**: openAi API 과 같은 도구를 사용하여 애플리케이션에 AI 기능 통합\n- **멀티모달 데이터 처리**: 텍스트, 이미지, 음성 등 다양한 데이터를 처리하여 사용자 경험 개선\n- **데이터 기반 의사결정**: 사용자 데이터를 분석하고 이를 기반으로 제품 설계 및 최적화.\n\n> 기술의 발전과 패러다임을 보면 항상 사용자에게 시간을 준다. 딱 5년. 2년도 안남았네 .. <br/>\n> 🏃🏿 지금부터 SpringAI 를 기점으로 AI 와 빠르게 친해지는 길로 달려보는 수 밖에.\n\n\n## Spring AI란 무엇인가?\n\n![출처 - https://spring.io/projects/spring-ai](image-3.png)\nSpring AI는 Java 개발자를 위한 AI 통합 프레임워크다. 기존에 AI 기능을 추가하려면 Python, 머신 러닝, 딥 러닝에 대한 광범위한 지식이 필요했는데 Spring AI를 사용하면 개발자가 OpenAI의 GPT-4 및 DALL-E 3의 기능을 쉽 게 활용할 수 있어, Java 개발자가 복잡한 인공 지능 기능에 액세스 할 수 있게 되었다. Spring 기술과 자연스럽게 연결되기 때문에 AI 기술을 `처음부터` 배우지 않아도 된다.\n\n## 왜 Spring AI로 시작해야 할까?\n\nSpring AI는 복잡한 AI 기술을 Java 개발자가 쉽게 접근할 수 있도록 단순화 되어있다. 굳이 채택하려는 이유라고 하면 다음과 같다.\n- **효율성**: 기존 Spring 생태계를 활용해 빠르게 시작 가능.\n- **확장성**: 다양한 모델과 데이터베이스를 유연하게 교체 및 확장 가능.\n- **생산성 향상**: 반복 작업을 자동화하고, 개발자가 중요한 문제 해결에 집중할 수 있도록 도움.\n\n## Spring AI로 무엇을 만들 수 있을까?\n\nSpring AI를 활용하면 다음과 같은 애플리케이션을 개발할 수 있다.\n- RAG 기반 검색 시스템: 질문에 대해 정확한 답변을 제공하는 검색 엔진.\n- 대화형 챗봇: OpenAI GPT-4와 연동된 스마트 대화 시스템.\n- 이미지 분석 및 생성: 멀티모달 기능을 활용한 이미지 처리 애플리케이션.\n\n> Toy Project 딱대 🥰  마지막으로 Spring AI 의 주요 기능과 설명으로 이번 포스팅을 마치며, <br/> 대화형 chat api 를 open ai 를 활용하여 toy project 를 다루는 방향으로 2 편을 작성해보려고 한다.\n\n## 주요 기능 과 설명\n| 기능                              | 설명                                                                 | 장점                                                                                       |\n|--------------------------------------|-----------------------------------------------------------------------------|--------------------------------------------------------------------------------------------------|\n| Boot Auto Configuration Support      | Spring Boot와의 통합으로 AI 기능을 쉽게 설정할 수 있다.                     | 복잡한 설정 코드를 줄여 개발 속도를 높인다.                                                            |\n| Multiple AI Support                  | OpenAI, Hugging Face, Google BERT 등 여러 AI 모델을 쉽게 사용할 수 있다.    | 다양한 AI 모델 간의 비교와 최적화를 쉽게 수행할 수 있으며, 모델 변경 시 코드 수정이 최소화된다.                        |\n| ChatClient API                       | AI와 대화하는 기능을 쉽게 구현할 수 있다.                                  | 대화형 AI 애플리케이션을 쉽게 구축할 수 있으며, 사용자와의 상호작용을 원활하게 처리한다.                             |\n| Prompt Template                      | 프롬프트 템플릿을 통해 AI에 보낼 입력값을 쉽게 조정할 수 있다.               | 코드의 재사용성을 높이고, 다양한 요구 사항에 맞는 질의를 손쉽게 작성할 수 있다.                                    |\n| Vector Embedding and Search          | 문서를 벡터화하고, 벡터 검색을 통해 고성능 검색 엔진을 구현할 수 있다.       | 복잡한 데이터를 효율적으로 검색하고 분석할 수 있으며, 이는 정보 검색 및 추천 시스템에 유용하다.                        |\n| Advisors API                         | 반복적인 생성 AI 패턴을 캡슐화하고, 데이터를 변환하여 다양한 모델과 사용 사례에 걸쳐 이식성을 제공한다. | AI 애플리케이션의 구조적 설계를 간소화하고, 성능을 최적화하며, 변화하는 요구사항에 빠르게 적응할 수 있다.              |\n| Retrieval Augmented Generation (RAG) | 정보 검색과 생성 AI를 결합하여 더 정확하고 신뢰할 수 있는 콘텐츠를 생성하는 기술을 지원한다. | 대규모 언어 모델의 한계를 보완하여 질문에 대한 더 정확한 답변을 제공한다.                                        |\n| Observability and Model Evaluation   | AI 관련 작업에 대한 통찰력을 제공하고, 생성된 콘텐츠의 품질을 평가하는 도구를 지원한다. | AI 모델의 성능을 모니터링하고, 잘못된 응답을 방지하여 시스템의 신뢰성을 높인다.                                        |\n\n---\n"},{"excerpt":"팀 이동을 하면서 알게된 Redis 의 존재  Redis 로고는 무슨 의미일까 .. \n별 모양으로, 데이터를 신속하게 저장하고 검색하는 그의 주요 기능을 상징한다. \n별은 네트워크 노드와 데이터 속도를 연상시키며, Redis의 효율성과 성능에 초점을 맞춘다. \n이 로고는 주로 빨간색과 흰색으로 구성되어 있으며, 이는 Redis의 신속함과 역량을 대표한다.…","fields":{"slug":"/basic/"},"frontmatter":{"date":"April 02, 2024","title":"Redis","tags":["Redis"]},"rawMarkdownBody":"\n## 팀 이동을 하면서 알게된 Redis 의 존재\n![img_4.png](img_4.png)\n\n> Redis 로고는 무슨 의미일까 .. <br/>\n별 모양으로, 데이터를 신속하게 저장하고 검색하는 그의 주요 기능을 상징한다. <br/>\n별은 네트워크 노드와 데이터 속도를 연상시키며, Redis의 효율성과 성능에 초점을 맞춘다. <br/>\n이 로고는 주로 빨간색과 흰색으로 구성되어 있으며, 이는 Redis의 신속함과 역량을 대표한다. <br/>\nRedis는 주로 데이터베이스, 캐시, 메시지 브로커 등 다양한 방식으로 사용되며, <br/>\n이러한 용도를 반영하듯 로고는 단순하면서도 인식하기 쉽게 디자인 되었다. - feat G 선생 <br/>\n\n## 본격, 본인 이 알고있던 Redis 란\nKey Value 형식으로 응답속도가 무척 빠른 NoSql DB <br/>\n흠 … 본격 Redis 라는 친구를 파헤치기 앞서, 캐시 라는 본질적인 키워드 부터 살펴보자.\n\n## 캐시 란\n`요청 결과를 어딘가에 미리 저장해 두었다가 재 요청이 왔을때 빨리 주는것`\n\n## DB 엔 캐시가 없나 ..?\n- RDB 도 사실 내부적으로 캐시가 있다.\n  - 그런데 여러 query 로 계속 접근 하다보면, 기존의 캐시를 날리고 Disk 에서 새로 읽어야 한다.\n\n## 효율적인 방법이 없을까.\n`뭔가 데이터를 질의 하는 패턴?` 이라던지 ...\n\n## 파레토의 법칙에 대해서 들어 봤나 ?\n![img_5.png](img_5.png)\n\n<strike> 세상은 역시 20% 의 진실과  80% 의 구라 가 진리 </strike> <br/>\n-> 전체 요청의 80% 는 20% 의 사용자 라는 이야기\n\n## 가장 보통의 캐시 사용법 은 어떻게 될까 ?\n\n널리 알려진 방법으로는 `Look aside cache` 가 존재한다. <br/>\n웹 서버 측에서 `특정 데이터` 를 요청 → 캐시 있니 ? (캐시에 먼저 물어봄) → 있으면 반환 → 없으면 DB 조회 <br/>\n> 그밖에, write back 사용 <br/>\n가장 널리 알려진 모델은 ELK ← 로그 수집했다가 한번에 write ! ( 좀 야매가 섞여있다 ) <br/>\n\n## 아니, 그래서 Redis 는 왜 씀\n![img_6.png](img_6.png)\n- 너무 간단하다, 아래 와 같은 비용을 줄이기 위해서다\n  - 개발의 편의성\n  - 개발의 난이도\n  - `+@ 짜치는 일 줄여줄라고`\n\n## 짜치는 일 뭐가 있을까 ?\n\n- 랭킹 서버 직접 구현\n- 기타 = Redis 를 쓰면 좋은데 직접 구현할려면 좀 힘든 것 들\n  - 사실상 뭔가 편의로 만들어진 대부분의 Tool 과 FrameWork 은 외부 편의로 인해 개발자가\n    `비즈니스 로직에만 집중하기 위해서` 만듦\n\n## 내가 속한 팀의 어느 비즈니스 에서 Redis 를 사용할까\n\n- 환율 ( 매일 오전 9시 )\n- oAuth 인증토큰\n- 위클리 베스트 상품\n- 도시별 상품리스트\n\n## 단점은 ?\n사실 내가 회사 CEO 라면 툴좋고, 기술좋고, 세상좋고 뭐든 해도 됨.\n![img_7.png](img_7.png)\n\n> 나만의 회사가 아닌경우는 아주 인생을 하드코어하게 사는 수가 있다.\n\n## 어떨때 인생이 하드코어하게 될까? (~~무식할때)~~\n\n- 메모리 관리를 못했을때\n  - Physical Memory 이상을 사용할때\n- Replication 시\n  - 네트웍 이슈나, 사람의 작업으로 동시에 replication 재시도 되도록 하면 문제가 발생할 수 있음\n\n## 그럼 어떤 것들을 알아야 할까 ..?\n\n- Redis 서버 구조\n- Collection\n  - redis 의 자료구조\n- 효율적인 메모리 관리 방법\n- 장애 대응시\n- 그밖에 주의사항\n\n## 갈길 머네 .. 그래도 좋았어, 배워보자\n![img_8.png](img_8.png)\n\n## 나 빼고, 세상이 알고 있던 Redis 란\n- 정의:\n  - Remote Dictionary Storage의 약자로, 이름 그대로 원격 위치에 데이터를 저장하는 메모리 기반의 데이터 저장소다.\n  - 실시간으로 데이터를 처리해야 하는 다양한 애플리케이션에서 주로 사용됨.\n- 특징:\n  - 메모리 기반:\n    - 데이터를 메모리에 저장하여 높은 속도로 데이터 처리 및 접근이 가능하다.\n    - 이는 데이터베이스, 캐시, 메시지 브로커 등 다양한 형태로의 활용을 가능하게 한다.\n    - 하지만, 메모리는 휘발성이기 때문에 전원이 꺼지면 저장된 데이터는 없어진다.\n  - 싱글 스레드:\n    - 마술처럼 느껴질 수 있는 Redis의 빠른 처리 속도는 싱글 스레드 아키텍처에서 비롯된다.\n    - 이는 복잡한 동시성 처리나 락(lock) 없이 단순하고 신속한 데이터 처리를 가능하게 한다.\n    - 하지만, 멀티 코어 서버의 경우 하나의 CPU 코어만 사용한다는 의미이기도 하다.\n  - 처리량:\n    - 초당 5만에서 25만 요청을 처리할 수 있다는 점은 Redis의 처리 능력이 얼마나 뛰어난지를 잘 보여준다.\n  - 데이터 저장 형태:\n    - Key-Value 형식으로 간단하면서도 직관적인 데이터 관리를 가능하게 한다.\n    - 이는 개발자들이 효과적으로 데이터를 저장하고 관리할 수 있는 구조를 제공한다.\n- 장점\n  - 빠른 Read / Write 속도:\n    - 메모리 기반의 특성으로 인해 전통적인 디스크 기반 데이터베이스보다 읽기와 쓰기 속도가 월등히 빠르다.\n  - 다양한 아키텍처 지원:\n    - Stand Alone부터 시작해 Master-Slave, Sentinel, Cluster 등 다양한 구성으로 확장성과 높은 가용성을 제공한다.\n  - 파티셔닝:\n    - 더 큰 데이터 세트를 여러 서버에 분산하여 저장함으로써, 단일 서버의 메모리 한계를 극복하고, 처리량을 증가시킬 수 있다.\n  - 인기있는 이유:\n    - 대규모 배포가 용이하고, 다양한 프로그래밍 언어로 작성된 클라이언트 라이브러리 지원으로 인해 널리 사용된다.\n- 단점\n  - 휘발성 문제:\n    - 다만, 휘발성을 보완하기 위해 AOF와 RDB 스냅샷 같은 지속성 옵션을 제공하기도 한다. 이를 통해 데이터의 영속성을 확보할 수 있다.\n  - 단일 스레드 구조:\n    - 멀티 코어 서버의 모든 코어를 활용하지 못하는 한계가 있다.\n  - 메모리 단편화:\n    - 시간이 지나면서 메모리가 조각화되어 관리가 필요하다. 메모리를 효율적으로 관리하지 않으면, 시스템의 성능에 영향을 미칠 수 있다.\n  - 대용량 데이터 처리 부적합:\n    - 데이터의 양이 많아질수록 메모리와 디스크 간의 동기화에 시간이 오래 걸리고, 이로 인해 지연 시간이 발생하면서 전체 성능에 영향을 미칠 수 있다.\n\n> Redis는 고성능, 고확장성, 고가용성을 제공하는 다목적 데이터 저장소이다. <br/>\n> 하지만, 그 사용법과 환경에 따른 한계는 명확히 인지하고, 용도에 맞게 적절히 활용해야 한다.\n\n## 목적 : Cashing\n![img.png](img.png)\n> 자주 (사용되고, 반복되고) 빠르게 응답해야 되는것들 을 미리 준비해 두는것.\n\n## 일반적 사용 : Session Store, List Data Caching\n- List 형태의 데이터의 경우 일반 SQL 서버보다 약 10 배 이상의 성능을 낸다고 알려져있다.\n\n\n\n## Redis 구조\nRedis 는 크게 4가지의 구조로 볼 수 있다.\n\n- Stand Alone 모드\n  - 정의: Redis 서버 단 하나만 사용하는 기본적인 설정.\n  - 특징: 간단하게 설정 가능하며, 개인 프로젝트나 작은 규모의 서비스에 아주 적합.\n- Master-Replica 구성\n  - 정의: 하나의 마스터와 하나 이상의 복제(레플리카) 노드로 구성.\n  - 동작 방식: 마스터에서 데이터 변경 시, 레플리카는 마스터와 데이터 차이를 확인 후 동일하게 복사함.\n  - 고급 설정:\n    - 앞단에 로드 밸런서 배치 및 하트비트 감시를 통해 마스터 장애 발생 시, 스크립트를 실행하여 레플리카를 임의로 마스터로 승격시킬 수 있음. 이 과정이 자동화된 것이 Sentinel.\n- Sentinel 시스템\n  - 정의: Redis의 모니터링 및 자동 장애 복구 시스템.\n  - 기능:\n    - 마스터가 실패할 경우, 자동으로 레플리카 중 하나를 새 마스터로 승격시킴.\n    - 원래의 마스터가 복구되면, 이전 마스터 역할을 하던 노드는 레플리카로 전환됨.\n    - 배치 권장 사항: 마스터와 레플리카를 서로 다른 존(예: 데이터센터)에 배치하는 것이 좋음.\n- Cluster 모드\n  - 정의: 복수의 마스터와 복수의 레플리카가 있는 복잡한 구성.\n  - 필요 조건: 최소 3대의 노드가 필요하고, 각각의 레플리카가 붙는 형태.\n  - 특징:\n    - Sentinel을 따로 두지 않아도, 장애 상황 시 자동으로 상호 보완하는 메커니즘을 갖춤.\n    - 데이터 샤딩을 통해 성능면에서 개선됨. 임의로 데이터를 나눔으로써, 데이터를 여러 마스터에 분산 저장하여 처리 속도 및 확장성을 높임.\n\n> 각 구성 및 모드는 프로젝트의 요구사항과 시스템의 규모에 따라 선택할 수 있으며, Redis의 다양한 사용 방법을 통해 서비스의 안정성, 가용성 및 성능을 향상시킬 수 있다.\n\n![img.png](img_1.png)\n\n## 어떤 Redis 구조가 적절한가\n- 사전에 정의한 품질 요건에 따라 다르다.\n\nAvailability: 99.95% <br/>\nMaster 가 내려간다면 약 4시간 안에 복구되어야 함 <br/>\n-> 주말? 휴가? 정전?\n\nPerformance: Read 300Kb/s <br/>\n-> 실제 benchmark test 수행 <br/>\n\nEfficiency\n-> 확보한 자원 VM 2대로 구성 가능한가 ?\n\n"},{"excerpt":"문득 java 21 이 등장하면서 virtual Thread 가 hot 한 지금..  한물 간다는 webFlux 를 공부하는게 맞을까 ...? 아니다... 왜 사라지는지 확실하게 짚고 넘어가는 게 맞다... cpu Bound 와 IO Bound 에 대해서 알아보자 단순 cpu 를 쓴다 라고 끝나는게 아니라, 다수의 데이터에 대한 집계 혹은 암호화 등 cp…","fields":{"slug":"/cpu-bound-vs-io-bound/"},"frontmatter":{"date":"January 12, 2024","title":"CPU Bound 와 IO Bound","tags":["webFlux"]},"rawMarkdownBody":"\n# 문득 java 21 이 등장하면서 virtual Thread 가 hot 한 지금..\n![img.png](img.png)\n### 한물 간다는 webFlux 를 공부하는게 맞을까 ...?\n> 아니다... 왜 사라지는지 확실하게 짚고 넘어가는 게 맞다...\n\n### cpu Bound 와 IO Bound 에 대해서 알아보자\n- 단순 cpu 를 쓴다 라고 끝나는게 아니라, 다수의 데이터에 대한 집계 혹은 암호화 등 cpu 계산 능력에 따라 성능이 좌지우지 되는 능력을 말한다.\n\n### 아래 그림을 보자\n![img_1.png](img_1.png)\n\n위 그림을 보면 `application 영역`, `커널 영역`, `하드웨어 영역` 을 계층화 하여 추상화로 나타낸 그림이다. <br/> \n여기서 동시간에 하나의 명령어를 처리할 수 있는 CPU core 가 한개 있다고 가정해보자 <br/>\n\napplication 은 실행되는 프로세스라고 보면 된다. <br/>\n이때 물리적인 cpu core 에 명령을 내린다고 가정해보자 <br/>\n\n![img_2.png](img_2.png)\n\n그리고 어플리케이션이 N 개가 더 추가되어 단일 CPU 코어 1 에 각각의 작업을 동작시켰다고 가정해보자. <br/>\n\n![img_3.png](img_3.png)\n\n이떄 CPU 코어에서는 동시에 실행한 것처럼 보일수 있다 <br/>\n\n> 그럼 동시에 `병렬` 로 처리한걸까 ? \n\n![img_4.png](img_4.png)\n\n그렇지 않다. 동시간대 하나의 명령만 처리 할 수 있기 때문에, 타임 슬라이스를 아주 잘게 나눠서 잘라보면 <br/>\n실제로 어플리케이션 1 번과 2 ... N 번이 번갈아 가면서 실행하게 된다. <br/>\n\n이렇게 번갈아 가면서 실행하는 과정을 OS 에서는 Context Switching 이라고 한다.\n> 실행관점에서 문맥을 바꾸었다. 라는 의미다.\n\n이러한 컨텍스트 스위칭 (ContextSwitching) 작업들은 CPU Bound 어플리케이션 에서 성능 저하를 가져오게 되는데 <br/>\n\n그림으로 보면 아래와 같다.\n\n![img_5.png](img_5.png)\n\n어플리케이션이 실행되어 메모리에 로드되고 프로세스로 동작하게 될텐데. <br/>\nCPU 로 스케줄링 되어 실행될때, 기계어 실행을 위해 필요한 데이터들을 cpu Register 로 미리 가져오게 된다. <br/>\n\n그리고 ALU 를 통해 실제 계산을 진행하게 되는데 Register 에는 기존에 어떤 명령까지 진행했는지를 함께 저장 해 놓고 <br/>\n필요에 의해 캐시를 해놓기 때문에, 동일한 프로세스의 일을 꾸준히 하면 할 수록 성능적으로 더 효과 적이다.\n\n![img_6.png](img_6.png)\n\n컨텍스트 스위칭은 위 그림과 같이 어플리케이션 2번을 실행시키기 위해 Register 정보를 초기화 하는 과정부터 시작한다. <br/>\n정확히는 어플리케이션 1 번이 실행했던 기존 실행 정보들을 메모리에 별도 저장 해 놓고, 2 번 어플리케이션 데이터 정보를 가져와서 다시 Register 적재를 한 뒤 명령어들을 실행하게 된다. <br/>\n하나의 CPU 에서 다수의 프로세스들이 번갈아 가면서 cpu 작업들을 진행해야 하기 때문에 성능상 오버헤드가 발생한다고 할 수 있다. <br/>\n\n### 그럼 여기서 문제...\n![img_7.png](img_7.png)\n\n위 어플리케이션 들을 어떻게 실행시키는게 가장 빠를까 \n> 하나씩 순차적으로 실행하는게 가장 빠르다 ( 너무 당연한가 ? ) <br/>\n> 컨텍스트 스위칭 이라는 오버헤드가 있기 때문 <br/>\n\n### 어떻게 하면 CPU Bound 상황을 효과적으로 만질 수 있을까 ?\n![img_8.png](img_8.png)\n\n흔히 말할 수 있는 정략은 위와 같이 병렬 처리 되어야 효과적이다. <br/>\n동 시간대 각각의 명령어를 동 시간대에 처리할 수 있기 때문이다. <br/>\n\n## I/O Bound 란\n입출력 장치의 중점적인 작업들을 말한다. <br/>\n대표적인 작업들은 키보드와 같은 사용자 입력, 디스크 파일 복사, 네트워크를 통한 데이터를 주고받는 행위들을 모두 I/O 작업이라고 한다.\n![img_9.png](img_9.png)\n\n위 그림과 같이 client 와 server 는 연결이 되어있는 상태이고, Hello 라는 문자열을 네트워크를 통해 전송한다고 가정해보자. <br/>\n\n![img_10.png](img_10.png)\n\nNIC ( Network Interface Card ) 장치 는 네트워크 패킷을 주고 받는 역할을 맡고 있다. <br/>\nClient 가 전달한 Hello 패킷을 Nic 장치를 통해 전달받고, 커널에서 네트워크 프로토콜을 진행하게 되는데 <br/> \n서버 application 입장에선, Kerner 에서 패킷을 전달받기 전까지 ```대기``` 를 하게 된다. <br/>\nNic 장치 로 부터 패킷을 받고 커널 까지의 과정 또한 CPU 사용이 필요한 영역이긴 한데, <br/>\napplication 관점에서는 패킷을 수신 완료까지 를 대기하기 때문에, CPU 를 중점적으로 사용하지 않는 상태라고 볼 수 있다. <br/>\n만약 패킷이 오지 않았다 라고 가정한다면, 해당 서버의 프로세스는 계속해서 대기를 하게 되는것이다. <br/>\n\n## Web Application 서버 관점에서 어떠한 I/O 들이 있을까\n![img_11.png](img_11.png)\n\n그림으로 보면 클라이언트로 부터 전달 받는 http 프로토콜을 처리하는것도 web Application 에서는 network I/O 이고, <br/> \nWeb Application 에서 비즈니스 로직 이후 DB 에 쿼리하는 영역도 I/O 이다. <br/>\n또한 DB 시스템에서 데이터를 조회하고, 삭제하고, 저장하는것도 I/O 라고 볼 수 있고, <br/>\nWeb Application 에서 외부 API 서버 요청 에 대한 것도 네트워크 I/O 가 발생하게 된다 <br/>\n\n> 하나의 웹 서비스 에서도 I/O 작업이 여기저기 산재되어 있는데, 반드시 인지하고 있어야 할 개념이다.\n\n## 만약 클라이언트로 부터 많은 요청이 들어오게 된다면, 어떻게 해야할까\n전통적인 해결 방법은 webApplication Thread 갯수를 늘리는 것이다.\n![img_13.png](img_13.png)\n\nThread Per Request 혹은 Thread for Connection 이러고도 하는데, 이는 <br/>\n하나의 요청에 하나의 Thread 가 필요하다는 의미이다. <br/>\n\n예를들어 굉장히 많은 Thread 가 실행된다고 가정한다면, <br/>\n성능 관점에서 CPU 컨텍스트 스위칭을 고려해야 하는데, 이런 컨텍스트 스위칭 오버헤드를 감수하더라도 I/O 요청을 최대한 처리할 수 있도록 하는 전략이라고 볼 수 있다. <br/>\n\n만약에 하나에 Thread 가 하나의 연결을 처리하고 있는 순간 다른 추가 요청이 있게 되면, <br/>\n대기를 하는게 아니라 또다른 Thread 를 처리하게 된다. <br/>\n\n만약 대량의 요청을 처리하기 위해 요청 수 만큼 Thread 갯수를 늘리게 되면 결국 OOM 이 나버리게 된다.<br/>\n만약 10만의 요청을 동시처리하고 싶다고 가정한다면, `(10 만 * 스레드 크기 )` == `메모리 용량` 이 되버린다.<br/>\n거기에 하드웨어 최대 메모리까지 사용하게 되면 시스템이 아예 동작하지 못할수도 있다.<br/>\n\n커널에는 OOM 이라는 안전장치가 존재한다. ( 주요 프로세스를 Kill 해서 시스템 다운을 예방하는 역할 )<br/>\n\n반면 사용이 완료된 Thread 를 삭제하는것도 문제다. <br/>\n새로 들어오는 요청에 의해 다시 만들어야 되니까 ..<br/>\n결국 쓰레드를 관리해야 하는것이 성능 관점에서 손해이다. <br/>\n\n이떄문에 Thread Pool 이 해결 방안으로 볼 수 있겠다. <br/>\n\n> 가용 가능한 다수의 쓰레드를 미리 만들어 놓고, <br/>\n> 요청이 들어오면 미리 만들어 놓은 쓰레드를 활용하고 사용이 다 했으면 해당 쓰레드를 다시 쓰레드 풀 에 반납하는 전략을 말한다. <br/>\n\n\n\n"},{"excerpt":"코들린의 현재와 미래 코틀린을 배워야하는 이유 코틀린은 IntelliJ로 유명한 젯브레인사에서 만든 언어이기 때문에 IntelliJ에서 자동완성, 자 바-코틀린 변환, 코루틴 등 코틀린 관련 편의 기능을 완벽하게 지원 자바는 발표된지 20년이 넘었지만 코틀린, C#, 스위프트와 같은 현대적 언어에 비해 기능 이 부족함 자바에서 Best-Practice로 …","fields":{"slug":"/kotlin/"},"frontmatter":{"date":"January 12, 2024","title":"코틀린의 현재와 미래","tags":["코틀린"]},"rawMarkdownBody":"\n# 코들린의 현재와 미래\n### 코틀린을 배워야하는 이유\n- 코틀린은 IntelliJ로 유명한 젯브레인사에서 만든 언어이기 때문에 IntelliJ에서 자동완성, 자 바-코틀린 변환, 코루틴 등 코틀린 관련 편의 기능을 완벽하게 지원\n- 자바는 발표된지 20년이 넘었지만 코틀린, C#, 스위프트와 같은 현대적 언어에 비해 기능 이 부족함\n- 자바에서 Best-Practice로 불리는 기법들을 언어적 차원에서 기본 제공\n- 자바에 비해 문법이 간결하기 때문에 가독성과 생산성이 높고 오류 가능성이 적어진다\n\n```kotlin\ndata class Person(\n        val name: String, \n        val age: Int, \n        val email: String\n) // equals(), hashCode(), toString() 등 유용한 함수를 자동 생성\n\nobject MyCompany { // 싱글턴 객체 \n    const val name: String = \"MyCompany\"\n}\n\n// 탑- 레벨 함수로 클래스 외부에서 함수 작성 가능\nfun main() {\n    // `new` 키워드 없이 객체 생성\n    val person = Person(\"이상훈 \", 35, \" digimon1740 @gmail.com \")\n}\n```\n\n### 좀더 파해쳐 보자\n- 문법 간결\n- data class 라는 기능을 사용하게 되면\n  - 자동으로 equals, hashcode, toString 을 자동으로 생성함\n- object 라는 키워드를 사용하게되면\n  - 간단하게 싱글턴 객체를 만들어준다.\n- 함수를 탑 레벨에 위치\n  - 탑 레벨 함수는 클래스 외부에서 함수를 작성할 수 있는 기능이다. ( 별도의 클래스 없이 작성가능 )\n  - 반면 자바에서는 기본적으로 클래스를 만들고 그 안에서 메서드를 만든다.\n- new 키워드 없이 객체를 만들 수 있다.\n- 멀티 플랫폼 언어이다\n  - 서버개발\n  - e.g ) 모바일 앱, 프론트 js, 안드로이드\n\n### 기업의 개선점\n- google 의 경우 npe 를 33% 절감 함\n- 그로인해 사용자 환경은 크게 향상 시켰다.\n\n### 코틀린 타임라인\n- 2016년 2월 코틀린 1.0 릴리즈\n- 2017년 1월 스프링 프레임워크 5.0 부터 코틀린 공식 지원 발표\n- 2017년 5월 구글 IO 에서 안드로이드 공식 지원 언어로 발표\n- 2019년 5월 구글 IO 에서 안드로이드 개발시 최우선 언어 (Kotlin-First) 발표\n- 2022년 5월 코틀린 1.7 베타 릴리즈\n- ...\n\n# 자바에는 있는데 코틀린엔 없는기능\n### 체크드 익셉션(Checked Exception)\n- 자바의 익셉션 계층\n- Throwable : 예외 계층의 최상위 클래스\n- Error : 시스템에 비정상적인 상황이 발생 예측이 어렵고 기본적으로 복구가 불가능 함\n  - e.g) OutOfMemoryError, StackOverflowError, etc\n- Exception : 시스템에서 포착 가능하여 etc (try-catch) 복구 가능\n  - 예외 처리 강제 IOException, FileNotFoundException,\n  - @Transactional 에서 해당 예외가 발생하면 기본적으론 롤백이 동작하지 않음\n    - rollbackFor: 를 사용해야함\n- RuntimeException\n  - 런타임시에 발생하는 예외 예외 처리를 강제하지 않음\n  - e.g ) NullPointerException, ArrayIndexOutOfBoundsException, etc\n\n![img.png](img.png)\n\n- java 에서 체크드 익셉션은 무조건 try catch 로 감싸줘야 하거나 throw 라는 키워드로 예외를 전파하지 않으면 컴파일 에러가 발생.\n```java\ntry {\n    Thread.slepp(1);\n} catch (InterrupedException e) {\n    // 예외처리    \n}\n```\n- kotlin 에서는 체크드 익셉션을 강제 하지 않는다.\n  - 그러나 원한다면 가능하다.\n  - 자바에서 의미없는 체크드 exception 을 지양하는듯해.\n\n### 기본 자료형\n- 자바는 원시 자료형을 지원하며 객체로된 레퍼런스 타입도 지원한다.\n```java\nint i = 0;\nInteger ii = 0;\nString str = ii.toString();\n```\n- 코틀린은 레퍼런스 타입만 지원한다.\n```kotlin\nval i: Int = 0;\nval str: String = i.toString();\n```\n\n- 코틀린의 레퍼런스 타입은 최적화된 방식으로 컴파일 한다.\n```kotlin\nint i = 0;\nString str = String.valueOf(i);\n```\n\n--\n### 정적멤버\n- 자바는 static 키워드로 정적멤버를 선언한다.\n```java\npublic class JavaClass {\n    static int i = 0;\n    \n    public static void staticMethod() {\n        // ...\n    }\n}\n```\n- 코틀린은 companion object 로 대체\n```kotlin\nclass KotlinClass {\n    companion object {\n        val i: Int = 0;\n        fun function() {\n            // ...\n        }\n    }\n}\n```\n\n### 3항 연산자\n- 자바\n```java\nString animalSound = \"호랑이\".equals(animal) ? \"어흥\" : \"야홍\";\n```\n- 코틀린은 if else 로 대체한다.\n```kotlin\nval animalSound: String = if (\"호랑이\" == animal) \"어흥\" : \"야홍\";\n```\n---\n\n### 세미콜론\n- 자바는 무조건 ; 세미콜론이 붙지만 코틀린은 안붙는다.\n```java\nBoolean isAdmin = userService.isAdmin(userId);\n```\n\n```kotlin\nval isAdmin: Boolean = userService.isAdmin(userId)\n```\n\n# 코틀린에는 있는데 자바에는 없는기능\n### 확장\n- 개발자가 임의로 객체의 함수나 프로퍼티를 확장해서 사용할 수 있다.\n\n```kotlin\nfun String.first(): Char {\n    return this[0]\n}\n\nfun String.addFirst(char: Char): String {\n    return char + this.substring(0)\n}\n\nfun main() {\n    println(\"ABCD\".first()) // 출력 A\n    println(\"ABCD\".addFirst('Z')) // 출력 ZABCD \n}\n```\n\n### 데이터 클래스\n- 데이터를 보관하거나 전달하는 목적을 가진 불변 객체로 사용\n\n```kotlin\ndata class Person(val name: String, val age: Int) {\n    // hashCode(), equals(), toString() 자동생성됨\n    // 이외에도 copy(), componentN 도 유용함.\n}\n```\n\n- 기존 자바에선 주로 lombok 을 사용\n\n```java\n@Getter\npublic class Person {\n    private final String name;\n    private final int age;\n}\n```\n\n```kotlin\n// jdk 15 에선 record 라는 이름이 추가됨\npublic record Person(String name, int age) {\n    \n}\n```\n--\n\n# 문자열 템플릿\n- 문자열에 변수를 사용하거나 여러행으로 된 텍스트 블록을 사용 할 수 있다.\n```kotlin\nval text = \"World\"\nval greeting = \"Hello, ${text}\"\n\nprintln(greeting) // Hello, World\n\n//  문자열 템플릿 기반의 다이나믹 쿼리\nfun sql(nameIncluded: Boolean) =\n        \"\"\"\n          SELECT id, name, email, age \n          FROM users \n          WHERE id = :id ${\n                if (nameIncluded) {\n                  \"\"\"\n                  AND name = :name\n                  \"\"\" \n                } else \"\"\n            }\n        \"\"\"\n```\n\n### 기타\n- 스마트 캐스트 실드 클래스 (Jdk15 추가)\n- 위임\n- 중위 표현식\n- 연산자 오버로딩\n- 코루틴\n- etc\n\n\n# 공식문서\n- https://docs.spring.io/spring-framework/reference/web/webmvc/mvc-servlet.html\n- 공식 문서의 샘플 코드를 보면 kotlin 탭을 제공\n\n![img_1.png](img_1.png)\n\n# Spring initializr\n- 기본 언어로 코틀린을 선택할 수 있고 코틀린인 경우 Gradle Project를 선택하면 빌드 설정 을 기반으로 생성해준다\n- Spring initialzr 를 통해 생성된 build.gralde.kts\n\n```gradle\nimport org.jetbrains.kotlin.gradle.tasks.KotlinCompile\n\nplugins { \n    id(\"org.springframework.boot\") version \"2.6.7\" \n    id(\"io.spring.dependency-management\") version \"1.0.11.RELEASE\" \n    kotlin(\"jvm\") version \"1.6.21\" \n    kotlin(\"plugin.spring\") version \"1.6.21\"\n}\n\ngroup = \"com.example\"\n\nversion = \"0.0.1-SNAPSHOT\"\n\njava.sourceCompatibility = JavaVersion.VERSION_11\n\nrepositories { \n    mavenCentral() \n}\n\ndependencies { \n    implementation(\"org.springframework.boot:spring-boot-starter\") \n    implementation(\"org.jetbrains.kotlin:kotlin-reflect\") \n    implementation(\"org.jetbrains.kotlin:kotlin-stdlib-jdk8\") \n    testImplementation(\"org.springframework.boot:spring-boot-starter-test\") \n}\n\ntasks.withType<KotlinCompile> { \nkotlinOptions { \n        freeCompilerArgs = listOf(\"-Xjsr305=strict\") jvmTarget = \"11\" \n    } \n}\n\ntasks.withType<Test> { \n    useJUnitPlatform() \n}\n```\n\n\n- 코틀린 스프링 프로젝트에서 필수적인 플러그인\n  - kotlin(\"plugin.spring\")\n\n- 코틀린 스프링 프로젝트에서 필수적인 의존성\n  - org.jetbrains.kotlin:kotlin-reflect\n  - org.jetbrains.kotlin:kotlin-stdlib\n\n이외에도 plugin.jpa, jackson-module-kotlin 등 프로젝트를 구성하면서 필요한 플러그인 과 <br/>\n코틀린 의존성이 있고 Springinitialzr에서 프로젝트를 구성할 경우 자동으로 세팅해준다\n\n# 스프링 부트\n```\n@SpringBootApplication class DemoApplication\n\n// fun 탑- 레벨 함수이므로 클래스 바깥에서{ 호출\nmain(args: Array<String>) {\n    runApplication<DemoApplication>(*args)\n}\n```\n\n### @ConfigurationProperties\n- 스프링 애플리케이션에 지정한 설정을 기반으로 설정 클래스를 만들때, <br/>\n  @ConstructorBinding 을 사용하면 setter가 아닌 생성자를 통해 바인딩 하므로 <br/>\n  불변 객체를 쉽게 생성할 수 있다.\n\n```kotlin\n@ConstructorBinding\n@ConfigurationProperties(\"example.kotlin\") \n\ndata class KotlinExampleProperties(\n                val name: String,\n                val description: String,\n                val myService: MyService\n                ) {\n\ndata class MyService(\n            val apiToken: String,\n            val uri: URI\n        )\n\n}\n```\n\n### 테스트 지원\n- 기본 제공되는 Junit5 기반의 테스트를 특별한 설정 없이 그대로 사용이 가능하다\n- 모의 객체를 만들어 테스트하려면 Mockito 대신 MockK를 사용할 수 있다"},{"excerpt":"배포 전략에 관하여 문득 dev 환경에서 테스트를 할겸 \n열씸히 dev 브렌치를 merge 후 열씸히 젠킨스 빌드버튼을 누르던 중  배포 전략에 대한 내용을 생각해보게 되었습니다.  배포 전략 ? 모놀리틱 서비스 환경에서 마이크로 서비스 환경으로 바뀌면서 배포 주기가 짧아졌기 때문에 \n배포 전략이 필요하게 되었답니다.  중단 배포 방식, 다운타임 (Dow…","fields":{"slug":"/deploy-strategy/"},"frontmatter":{"date":"November 18, 2022","title":"배포전략","tags":["배포"]},"rawMarkdownBody":"\n# 배포 전략에 관하여\n\n문득 dev 환경에서 테스트를 할겸 <br/>\n열씸히 dev 브렌치를 merge 후 열씸히 젠킨스 빌드버튼을 누르던 중\n\n![](click.gif)\n\n배포 전략에 대한 내용을 생각해보게 되었습니다. <br/>\n\n# 배포 전략 ?\n모놀리틱 서비스 환경에서 마이크로 서비스 환경으로 바뀌면서 배포 주기가 짧아졌기 때문에 <br/>\n배포 전략이 필요하게 되었답니다. <br/>\n\n# 중단 배포 방식, 다운타임 (DownTime)\n\n중단 배포 방식은 배포 중에 서비스가 중단되는 방식입니다. <br/>\n사용자들은 자연스레 서비스가 중단되는 시간동안 서비스를 이용할 수 없게 되겠습니다. <br/>\n서비스를 사용할 수 없는 시간대를 downtime 이라고 합니다. <br/>\n때문에 현대에 웹 어플리케이션 에서 중단 배포 방식은 자연스레 사용하지 않게 되었습니다. <br/>\n그래서 등장한 전략이 \" 무중단 배포 \" 전략입니다.\n\n# 무중단 배포 전략의 종류 로는 크게 세가지가 있습니다.\n- Rolling 배포\n- Blue/Green 배포\n- Canary 배포\n\n각각의 전략에 따라 장단 점이 극명한데 <br/>\n주관적인 생각으로는 서비스의 특성에 따라 적절한 전략을 선택하는 것이 좋을 것 같습니다. <br/>\n\n## Rolling 배포\n\n사실 여러 블로그, 문서들을 찾아보면서 배포 전략에 대한 내용을 찾아보았는데 <br/>\n그림이 마땅치가 않습니다... <br/>\n제일 널리 알려져 있는 그림은 아래와 같으나, 제가 본 최고의 그림은 저작권이 있어서 아래 그림으로 대체하겠습니다. <br/>\n100 만의 트레픽을 받는 인스턴스가 총 3대가 띄워져 있다고 가정하겠습니다 :) <br/>\n\n\n3 대중 2대만이 운영 트레픽을 받게되고 1대는 LB (로드벨런서) 에서 떼어놓습니다. <br/>\n그렇게 2대만이 가용서버가 되고 트레픽은 각각 50만 50만 씩 사이좋게 나누어 받습니다. <br/>\n배포가 완료되고 다음차례인 서버에 배포를 진행합니다. <br/>\n이과정에서 로드벨런서 를 붙였다 뗏다를 반복하며, 순차적으로 모든 서버가 신규 서버로 점진적 교체가 이루어 지면서 배포가 완료됩니다. <br/>\n(물론 이때 트레픽은 100% 운영중인 서버에만 흘러가게 됩니다.) <br/>\n\n이것이 Rolling 배포방식이 되겠습니다 :) <br/>\n\n## 장점\n- 서비스 자원을 그대로 이용하기 때문에 낭비가 없습니다.\n- 배포를 차례로 진행하기 때문에 상황에 따라 손쉽게 롤백이 가능하다는 점.\n\n## 단점\n- 구 버전과 신 버전이 공존하며, 호환성 문제가 발생할 수 있다는점.\n- 트레픽이 몰리다보니 도메인에 따라, 사용자들이 덜 몰리는 새벽작업이 필연적일 수 있다는점.\n\n## Blue/Green 배포\n\n역시 총 3대의 인스턴스가 띄워져 있다고 가정하겠습니다. <strike>그림에서 서버가 3개 라 가정함... </strike>  <br/>\n\n구버전이 배포되어 있는 인스턴스를 Blue, 신버전이 배포되어 있는 인스턴스를 Green 이라고 합니다. <br/>\n색깔에 많은 의의를 두지 않아도 됩니다 :) <br/>\n\n아무 의미가 없지만 레드 옐로 배포가 아닌 이유는, 우리가 보통 신호들에서 빨간불엔 안건ㄴ...<br/>\n\n아래 그림과 같이 구버전과 운영중인 블루 서버가 있고, <br/>\n신버전과 배포중인 그린 서버가 있습니다. <br/>\n\n그린 서버가 배포가 완료되면, 블루 서버와 그린 서버의 역할을 바꿔줍니다. <br/>\n그렇기 때문에 한번에 배포가 가능해 지겠죠 :)\n\n## 장점\n- Rolling 배포와 다르게 구버전과 신버전이 공존하지 않기 때문에 호환성 문제가 발생하지 않습니다.\n- 한번에 배포가 가능하기 때문에 트레픽이 몰리는 새벽작업이 필요없습니다.\n\n## 단점\n- 운영 서버가 운영되고 있는 서비스 자원이 두배로 들게 됩니다.\n\n## Canary 배포\n카나리 배포는 조금 슬픈 이야기가 존재합니다. <br/>\n19세기만 해도 탄광에서 가스 중독 사고가 많았답니다. <br/>\n광부들에게 희망을 준 것은 카나리아 라는 새였습니다. <br/>\n\n이 새는 일산화탄소와 메탄에 유독 약하기 때문에 광부들은 카나리아를 새장에 넣어 갱도로 들어가서 <br/>\n석탄을 캐다가 카나리아가 이상증세를 보이면 즉시 탈출했다. (아차 싶을땐 역시 도망이 최고) <br/>\n\"이상 증세가 보이면 바로 롤백 이 핵심\" <br/>\n\n카나리 배포는 아래 그림과 같이 소규모 유저들에게 신버전을 배포하고, <br/>\n이상증세가 보이면 바로 롤백을 진행하는 전략입니다. <br/>\n\n그러나 이런 전략 덕분에 A/B 테스트가 가능해 지겠네요 :) <br/>\n물론 점진적으로 신버전을 확장하다가 뒤늦게 이상증세를 확인하여 롤백하게 되는날엔 마음이 아프겠지만요 :) <br/>\n\n## 장점\n- 단계적인 전환 방식을 통해 부정적 영향을 최소화하고 상황에 따라 트래픽 양을 늘리거나 롤백할 수 있다.\n- A/B 테스트가 가능하다.\n\n## 단점\n- 신버전과 구버전이 동시에 존재하기 때문에 버전관리가 까다롭다.\n\n# 결론\n흥미로운 이름의 배포전략이 존재했고, <br/>\n모놀리식에서 마이크로서비스로 전환하면서 배포전략이 어떻게 변화했는지 알아보았습니다. <br/>\n\n## 운영 관점에서 느낀 주관적인 생각과 궁금증\n- 시간을 내어서 AWS 를 이용해 Blue Green 배포를 직접 진행해 보겠습니다. (나중에) <br/>\n- 도메인별 전략에 따라, 전략이 다를것 같습니다. <br/>\n- 결제 도메인의 경우는 어떤 전략 방식이 나을까 ? <br/>\n\n## 참고자료\n- https://hudi.blog/zero-downtime-deployment/\n- https://loosie.tistory.com/781"}]}},"pageContext":{}},"staticQueryHashes":[],"slicesMap":{}}