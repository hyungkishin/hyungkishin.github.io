{"componentChunkName":"component---src-pages-search-jsx","path":"/search/","result":{"data":{"allMarkdownRemark":{"nodes":[{"excerpt":"아이스 브레이킹 22 년 어느날, Back-end 개발자로 개발생활을 영위하며 바쁜 일상생활을 보내고 있었던 🍁가을무렵 이였다. 헤성처럼 나타나 개발자들에게 \"코더 계속 하실 ?\" 이라는 극딜을 준 G 선생. 솔직히 처음 모델만 해도 리펙토링 정도만 살짝 참고하는 정도여서 전혀 히지 않았다. 분명 그랬을 터인데, 24년 여름쯤 이였다. 일정 테트리스로 인…","fields":{"slug":"/spring-ai/"},"frontmatter":{"date":"March 29, 2025","title":"Ai. Spring AI 로 때워도 되나유? 1편","tags":["AI","Spring"]},"rawMarkdownBody":"\n## 아이스 브레이킹\n\n22 년 어느날, Back-end 개발자로 개발생활을 영위하며 바쁜 일상생활을 보내고 있었던 🍁가을무렵 이였다. 헤성처럼 나타나 개발자들에게 *\"코더 계속 하실 ?\"* 이라는 극딜을 준 G 선생. 솔직히 처음 모델만 해도 리펙토링 정도만 살짝 참고하는 정도여서 전혀 `긁`히지 않았다. 분명 그랬을 터인데, 24년 여름쯤 이였다. 일정 테트리스로 인하여 여러 프로젝트가 겹쳐 시간이 빠듯하였고 결국 생성형 AI 를 적극 활용하기로 하였다. 그 결과 무려 10배 혹은 20배나 되는 `생산성의 맛` 을 봐 버렸고. 요망한 AI 에게 의존하는 삶을 살게 되었다.\n![ㅎ...형!!!](image-2.png)\n\n의존 하다보니 느끼는 감정은 날것 그대로 쓰기엔 오류도 많고 아직 사람손이 타야하는 영역이 많긴한데, 점점 그 빈도가 **줄어들고 있다는 점**에서 불안과 걱정의 씨앗이 심어졌다. 정말 어느 순간 모르게 급격하게 발전해서 **\"비즈니스 영역까지 커버하게 된다면\"** 더이상 내 자신이 회사에 필요하지 않게될 날이 도래하겠다는 생각이 들었다. \"에이 ~ AI 는 아직 부족한 부분이 많으니 대체되지 않을거야\" 라는 **미련을 빨리 버려야 된다**고 생각했다. 그러나 처음부터 AI 의 모든 영역을 공부하기엔 현실적으로 많은 러닝커브가 따르고 막막하여 생각에 잠긴다.\n\n> 1️⃣ Web 개발자 관점에서 AI 를 활용하기 위해 어떤 개념들을 알아야 할까 🤔 ? <br/>\n> 2️⃣ Spring AI 가 있다는데, python 없이도 AI 기술들을 커버할 수 있는걸까 🤔 ? <br/>\n> 3️⃣ 많이 뒤쳐진것 같아 불안해. 빠르게 AI 기술들을 적용해보고 싶어 ‼️ <br/>\n\n## 돈워리. Web 개발자 관점에서 요구되는 AI 기술 부터\n웹 개발자는 AI 모델을 직접 연구하거나 신경망을 설계하는 사람이 아니다. **AI를 활용하여 제품을 개발하고 사용자 경험을 향상시키는 데 초점**을 맞추어야 한다. 단, 요구되는 지식은 다음과 같다.\n\n- **AI 기술 이해**: ( 머신러닝 딥러닝 기본 개념 ), AI 모델 작동 방식\n- **API 및 라이브러리 활용**: openAi API 과 같은 도구를 사용하여 애플리케이션에 AI 기능 통합\n- **멀티모달 데이터 처리**: 텍스트, 이미지, 음성 등 다양한 데이터를 처리하여 사용자 경험 개선\n- **데이터 기반 의사결정**: 사용자 데이터를 분석하고 이를 기반으로 제품 설계 및 최적화.\n\n> 기술의 발전과 패러다임을 보면 항상 사용자에게 시간을 준다. 딱 5년. 2년도 안남았네 .. <br/>\n> 🏃🏿 지금부터 SpringAI 를 기점으로 AI 와 빠르게 친해지는 길로 달려보는 수 밖에.\n\n\n## Spring AI란 무엇인가?\n\n![출처 - https://spring.io/projects/spring-ai](image-3.png)\nSpring AI는 Java 개발자를 위한 AI 통합 프레임워크다. 기존에 AI 기능을 추가하려면 Python, 머신 러닝, 딥 러닝에 대한 광범위한 지식이 필요했는데 Spring AI를 사용하면 개발자가 OpenAI의 GPT-4 및 DALL-E 3의 기능을 쉽 게 활용할 수 있어, Java 개발자가 복잡한 인공 지능 기능에 액세스 할 수 있게 되었다. Spring 기술과 자연스럽게 연결되기 때문에 AI 기술을 `처음부터` 배우지 않아도 된다.\n\n## 왜 Spring AI로 시작해야 할까?\n\nSpring AI는 복잡한 AI 기술을 Java 개발자가 쉽게 접근할 수 있도록 단순화 되어있다. 굳이 채택하려는 이유라고 하면 다음과 같다.\n- **효율성**: 기존 Spring 생태계를 활용해 빠르게 시작 가능.\n- **확장성**: 다양한 모델과 데이터베이스를 유연하게 교체 및 확장 가능.\n- **생산성 향상**: 반복 작업을 자동화하고, 개발자가 중요한 문제 해결에 집중할 수 있도록 도움.\n\n## Spring AI로 무엇을 만들 수 있을까?\n\nSpring AI를 활용하면 다음과 같은 애플리케이션을 개발할 수 있다.\n- RAG 기반 검색 시스템: 질문에 대해 정확한 답변을 제공하는 검색 엔진.\n- 대화형 챗봇: OpenAI GPT-4와 연동된 스마트 대화 시스템.\n- 이미지 분석 및 생성: 멀티모달 기능을 활용한 이미지 처리 애플리케이션.\n\n> Toy Project 딱대 🥰  마지막으로 Spring AI 의 주요 기능과 설명으로 이번 포스팅을 마치며, <br/> 대화형 chat api 를 open ai 를 활용하여 toy project 를 다루는 방향으로 2 편을 작성해보려고 한다.\n\n## 주요 기능 과 설명\n| 기능                              | 설명                                                                 | 장점                                                                                       |\n|--------------------------------------|-----------------------------------------------------------------------------|--------------------------------------------------------------------------------------------------|\n| Boot Auto Configuration Support      | Spring Boot와의 통합으로 AI 기능을 쉽게 설정할 수 있다.                     | 복잡한 설정 코드를 줄여 개발 속도를 높인다.                                                            |\n| Multiple AI Support                  | OpenAI, Hugging Face, Google BERT 등 여러 AI 모델을 쉽게 사용할 수 있다.    | 다양한 AI 모델 간의 비교와 최적화를 쉽게 수행할 수 있으며, 모델 변경 시 코드 수정이 최소화된다.                        |\n| ChatClient API                       | AI와 대화하는 기능을 쉽게 구현할 수 있다.                                  | 대화형 AI 애플리케이션을 쉽게 구축할 수 있으며, 사용자와의 상호작용을 원활하게 처리한다.                             |\n| Prompt Template                      | 프롬프트 템플릿을 통해 AI에 보낼 입력값을 쉽게 조정할 수 있다.               | 코드의 재사용성을 높이고, 다양한 요구 사항에 맞는 질의를 손쉽게 작성할 수 있다.                                    |\n| Vector Embedding and Search          | 문서를 벡터화하고, 벡터 검색을 통해 고성능 검색 엔진을 구현할 수 있다.       | 복잡한 데이터를 효율적으로 검색하고 분석할 수 있으며, 이는 정보 검색 및 추천 시스템에 유용하다.                        |\n| Advisors API                         | 반복적인 생성 AI 패턴을 캡슐화하고, 데이터를 변환하여 다양한 모델과 사용 사례에 걸쳐 이식성을 제공한다. | AI 애플리케이션의 구조적 설계를 간소화하고, 성능을 최적화하며, 변화하는 요구사항에 빠르게 적응할 수 있다.              |\n| Retrieval Augmented Generation (RAG) | 정보 검색과 생성 AI를 결합하여 더 정확하고 신뢰할 수 있는 콘텐츠를 생성하는 기술을 지원한다. | 대규모 언어 모델의 한계를 보완하여 질문에 대한 더 정확한 답변을 제공한다.                                        |\n| Observability and Model Evaluation   | AI 관련 작업에 대한 통찰력을 제공하고, 생성된 콘텐츠의 품질을 평가하는 도구를 지원한다. | AI 모델의 성능을 모니터링하고, 잘못된 응답을 방지하여 시스템의 신뢰성을 높인다.                                        |\n\n---\n"},{"excerpt":"Redis 를 활용한 분산 lock","fields":{"slug":"/basic/"},"frontmatter":{"date":"April 02, 2024","title":"Redis","tags":["Redis"]},"rawMarkdownBody":"\n## Redis 를 활용한 분산 lock\n\n"},{"excerpt":"문득 java 21 이 등장하면서 virtual Thread 가 hot 한 지금..  한물 간다는 webFlux 를 공부하는게 맞을까 ...? 아니다... 왜 사라지는지 확실하게 짚고 넘어가는 게 맞다... cpu Bound 와 IO Bound 에 대해서 알아보자 단순 cpu 를 쓴다 라고 끝나는게 아니라, 다수의 데이터에 대한 집계 혹은 암호화 등 cp…","fields":{"slug":"/cpu-bound-vs-io-bound/"},"frontmatter":{"date":"January 12, 2024","title":"CPU Bound 와 IO Bound","tags":["webFlux"]},"rawMarkdownBody":"\n# 문득 java 21 이 등장하면서 virtual Thread 가 hot 한 지금..\n![img.png](img.png)\n### 한물 간다는 webFlux 를 공부하는게 맞을까 ...?\n> 아니다... 왜 사라지는지 확실하게 짚고 넘어가는 게 맞다...\n\n### cpu Bound 와 IO Bound 에 대해서 알아보자\n- 단순 cpu 를 쓴다 라고 끝나는게 아니라, 다수의 데이터에 대한 집계 혹은 암호화 등 cpu 계산 능력에 따라 성능이 좌지우지 되는 능력을 말한다.\n\n### 아래 그림을 보자\n![img_1.png](img_1.png)\n\n위 그림을 보면 `application 영역`, `커널 영역`, `하드웨어 영역` 을 계층화 하여 추상화로 나타낸 그림이다. <br/> \n여기서 동시간에 하나의 명령어를 처리할 수 있는 CPU core 가 한개 있다고 가정해보자 <br/>\n\napplication 은 실행되는 프로세스라고 보면 된다. <br/>\n이때 물리적인 cpu core 에 명령을 내린다고 가정해보자 <br/>\n\n![img_2.png](img_2.png)\n\n그리고 어플리케이션이 N 개가 더 추가되어 단일 CPU 코어 1 에 각각의 작업을 동작시켰다고 가정해보자. <br/>\n\n![img_3.png](img_3.png)\n\n이떄 CPU 코어에서는 동시에 실행한 것처럼 보일수 있다 <br/>\n\n> 그럼 동시에 `병렬` 로 처리한걸까 ? \n\n![img_4.png](img_4.png)\n\n그렇지 않다. 동시간대 하나의 명령만 처리 할 수 있기 때문에, 타임 슬라이스를 아주 잘게 나눠서 잘라보면 <br/>\n실제로 어플리케이션 1 번과 2 ... N 번이 번갈아 가면서 실행하게 된다. <br/>\n\n이렇게 번갈아 가면서 실행하는 과정을 OS 에서는 Context Switching 이라고 한다.\n> 실행관점에서 문맥을 바꾸었다. 라는 의미다.\n\n이러한 컨텍스트 스위칭 (ContextSwitching) 작업들은 CPU Bound 어플리케이션 에서 성능 저하를 가져오게 되는데 <br/>\n\n그림으로 보면 아래와 같다.\n\n![img_5.png](img_5.png)\n\n어플리케이션이 실행되어 메모리에 로드되고 프로세스로 동작하게 될텐데. <br/>\nCPU 로 스케줄링 되어 실행될때, 기계어 실행을 위해 필요한 데이터들을 cpu Register 로 미리 가져오게 된다. <br/>\n\n그리고 ALU 를 통해 실제 계산을 진행하게 되는데 Register 에는 기존에 어떤 명령까지 진행했는지를 함께 저장 해 놓고 <br/>\n필요에 의해 캐시를 해놓기 때문에, 동일한 프로세스의 일을 꾸준히 하면 할 수록 성능적으로 더 효과 적이다.\n\n![img_6.png](img_6.png)\n\n컨텍스트 스위칭은 위 그림과 같이 어플리케이션 2번을 실행시키기 위해 Register 정보를 초기화 하는 과정부터 시작한다. <br/>\n정확히는 어플리케이션 1 번이 실행했던 기존 실행 정보들을 메모리에 별도 저장 해 놓고, 2 번 어플리케이션 데이터 정보를 가져와서 다시 Register 적재를 한 뒤 명령어들을 실행하게 된다. <br/>\n하나의 CPU 에서 다수의 프로세스들이 번갈아 가면서 cpu 작업들을 진행해야 하기 때문에 성능상 오버헤드가 발생한다고 할 수 있다. <br/>\n\n### 그럼 여기서 문제...\n![img_7.png](img_7.png)\n\n위 어플리케이션 들을 어떻게 실행시키는게 가장 빠를까 \n> 하나씩 순차적으로 실행하는게 가장 빠르다 ( 너무 당연한가 ? ) <br/>\n> 컨텍스트 스위칭 이라는 오버헤드가 있기 때문 <br/>\n\n### 어떻게 하면 CPU Bound 상황을 효과적으로 만질 수 있을까 ?\n![img_8.png](img_8.png)\n\n흔히 말할 수 있는 정략은 위와 같이 병렬 처리 되어야 효과적이다. <br/>\n동 시간대 각각의 명령어를 동 시간대에 처리할 수 있기 때문이다. <br/>\n\n## I/O Bound 란\n입출력 장치의 중점적인 작업들을 말한다. <br/>\n대표적인 작업들은 키보드와 같은 사용자 입력, 디스크 파일 복사, 네트워크를 통한 데이터를 주고받는 행위들을 모두 I/O 작업이라고 한다.\n![img_9.png](img_9.png)\n\n위 그림과 같이 client 와 server 는 연결이 되어있는 상태이고, Hello 라는 문자열을 네트워크를 통해 전송한다고 가정해보자. <br/>\n\n![img_10.png](img_10.png)\n\nNIC ( Network Interface Card ) 장치 는 네트워크 패킷을 주고 받는 역할을 맡고 있다. <br/>\nClient 가 전달한 Hello 패킷을 Nic 장치를 통해 전달받고, 커널에서 네트워크 프로토콜을 진행하게 되는데 <br/> \n서버 application 입장에선, Kerner 에서 패킷을 전달받기 전까지 ```대기``` 를 하게 된다. <br/>\nNic 장치 로 부터 패킷을 받고 커널 까지의 과정 또한 CPU 사용이 필요한 영역이긴 한데, <br/>\napplication 관점에서는 패킷을 수신 완료까지 를 대기하기 때문에, CPU 를 중점적으로 사용하지 않는 상태라고 볼 수 있다. <br/>\n만약 패킷이 오지 않았다 라고 가정한다면, 해당 서버의 프로세스는 계속해서 대기를 하게 되는것이다. <br/>\n\n## Web Application 서버 관점에서 어떠한 I/O 들이 있을까\n![img_11.png](img_11.png)\n\n그림으로 보면 클라이언트로 부터 전달 받는 http 프로토콜을 처리하는것도 web Application 에서는 network I/O 이고, <br/> \nWeb Application 에서 비즈니스 로직 이후 DB 에 쿼리하는 영역도 I/O 이다. <br/>\n또한 DB 시스템에서 데이터를 조회하고, 삭제하고, 저장하는것도 I/O 라고 볼 수 있고, <br/>\nWeb Application 에서 외부 API 서버 요청 에 대한 것도 네트워크 I/O 가 발생하게 된다 <br/>\n\n> 하나의 웹 서비스 에서도 I/O 작업이 여기저기 산재되어 있는데, 반드시 인지하고 있어야 할 개념이다.\n\n## 만약 클라이언트로 부터 많은 요청이 들어오게 된다면, 어떻게 해야할까\n전통적인 해결 방법은 webApplication Thread 갯수를 늘리는 것이다.\n![img_13.png](img_13.png)\n\nThread Per Request 혹은 Thread for Connection 이러고도 하는데, 이는 <br/>\n하나의 요청에 하나의 Thread 가 필요하다는 의미이다. <br/>\n\n예를들어 굉장히 많은 Thread 가 실행된다고 가정한다면, <br/>\n성능 관점에서 CPU 컨텍스트 스위칭을 고려해야 하는데, 이런 컨텍스트 스위칭 오버헤드를 감수하더라도 I/O 요청을 최대한 처리할 수 있도록 하는 전략이라고 볼 수 있다. <br/>\n\n만약에 하나에 Thread 가 하나의 연결을 처리하고 있는 순간 다른 추가 요청이 있게 되면, <br/>\n대기를 하는게 아니라 또다른 Thread 를 처리하게 된다. <br/>\n\n만약 대량의 요청을 처리하기 위해 요청 수 만큼 Thread 갯수를 늘리게 되면 결국 OOM 이 나버리게 된다.<br/>\n만약 10만의 요청을 동시처리하고 싶다고 가정한다면, `(10 만 * 스레드 크기 )` == `메모리 용량` 이 되버린다.<br/>\n거기에 하드웨어 최대 메모리까지 사용하게 되면 시스템이 아예 동작하지 못할수도 있다.<br/>\n\n커널에는 OOM 이라는 안전장치가 존재한다. ( 주요 프로세스를 Kill 해서 시스템 다운을 예방하는 역할 )<br/>\n\n반면 사용이 완료된 Thread 를 삭제하는것도 문제다. <br/>\n새로 들어오는 요청에 의해 다시 만들어야 되니까 ..<br/>\n결국 쓰레드를 관리해야 하는것이 성능 관점에서 손해이다. <br/>\n\n이떄문에 Thread Pool 이 해결 방안으로 볼 수 있겠다. <br/>\n\n> 가용 가능한 다수의 쓰레드를 미리 만들어 놓고, <br/>\n> 요청이 들어오면 미리 만들어 놓은 쓰레드를 활용하고 사용이 다 했으면 해당 쓰레드를 다시 쓰레드 풀 에 반납하는 전략을 말한다. <br/>\n\n\n\n"},{"excerpt":"코들린의 현재와 미래 코틀린을 배워야하는 이유 코틀린은 IntelliJ로 유명한 젯브레인사에서 만든 언어이기 때문에 IntelliJ에서 자동완성, 자 바-코틀린 변환, 코루틴 등 코틀린 관련 편의 기능을 완벽하게 지원 자바는 발표된지 20년이 넘었지만 코틀린, C#, 스위프트와 같은 현대적 언어에 비해 기능 이 부족함 자바에서 Best-Practice로 …","fields":{"slug":"/kotlin/"},"frontmatter":{"date":"January 12, 2024","title":"코틀린의 현재와 미래","tags":["코틀린"]},"rawMarkdownBody":"\n# 코들린의 현재와 미래\n### 코틀린을 배워야하는 이유\n- 코틀린은 IntelliJ로 유명한 젯브레인사에서 만든 언어이기 때문에 IntelliJ에서 자동완성, 자 바-코틀린 변환, 코루틴 등 코틀린 관련 편의 기능을 완벽하게 지원\n- 자바는 발표된지 20년이 넘었지만 코틀린, C#, 스위프트와 같은 현대적 언어에 비해 기능 이 부족함\n- 자바에서 Best-Practice로 불리는 기법들을 언어적 차원에서 기본 제공\n- 자바에 비해 문법이 간결하기 때문에 가독성과 생산성이 높고 오류 가능성이 적어진다\n\n```kotlin\ndata class Person(\n        val name: String, \n        val age: Int, \n        val email: String\n) // equals(), hashCode(), toString() 등 유용한 함수를 자동 생성\n\nobject MyCompany { // 싱글턴 객체 \n    const val name: String = \"MyCompany\"\n}\n\n// 탑- 레벨 함수로 클래스 외부에서 함수 작성 가능\nfun main() {\n    // `new` 키워드 없이 객체 생성\n    val person = Person(\"이상훈 \", 35, \" digimon1740 @gmail.com \")\n}\n```\n\n### 좀더 파해쳐 보자\n- 문법 간결\n- data class 라는 기능을 사용하게 되면\n  - 자동으로 equals, hashcode, toString 을 자동으로 생성함\n- object 라는 키워드를 사용하게되면\n  - 간단하게 싱글턴 객체를 만들어준다.\n- 함수를 탑 레벨에 위치\n  - 탑 레벨 함수는 클래스 외부에서 함수를 작성할 수 있는 기능이다. ( 별도의 클래스 없이 작성가능 )\n  - 반면 자바에서는 기본적으로 클래스를 만들고 그 안에서 메서드를 만든다.\n- new 키워드 없이 객체를 만들 수 있다.\n- 멀티 플랫폼 언어이다\n  - 서버개발\n  - e.g ) 모바일 앱, 프론트 js, 안드로이드\n\n### 기업의 개선점\n- google 의 경우 npe 를 33% 절감 함\n- 그로인해 사용자 환경은 크게 향상 시켰다.\n\n### 코틀린 타임라인\n- 2016년 2월 코틀린 1.0 릴리즈\n- 2017년 1월 스프링 프레임워크 5.0 부터 코틀린 공식 지원 발표\n- 2017년 5월 구글 IO 에서 안드로이드 공식 지원 언어로 발표\n- 2019년 5월 구글 IO 에서 안드로이드 개발시 최우선 언어 (Kotlin-First) 발표\n- 2022년 5월 코틀린 1.7 베타 릴리즈\n- ...\n\n# 자바에는 있는데 코틀린엔 없는기능\n### 체크드 익셉션(Checked Exception)\n- 자바의 익셉션 계층\n- Throwable : 예외 계층의 최상위 클래스\n- Error : 시스템에 비정상적인 상황이 발생 예측이 어렵고 기본적으로 복구가 불가능 함\n  - e.g) OutOfMemoryError, StackOverflowError, etc\n- Exception : 시스템에서 포착 가능하여 etc (try-catch) 복구 가능\n  - 예외 처리 강제 IOException, FileNotFoundException,\n  - @Transactional 에서 해당 예외가 발생하면 기본적으론 롤백이 동작하지 않음\n    - rollbackFor: 를 사용해야함\n- RuntimeException\n  - 런타임시에 발생하는 예외 예외 처리를 강제하지 않음\n  - e.g ) NullPointerException, ArrayIndexOutOfBoundsException, etc\n\n![img.png](img.png)\n\n- java 에서 체크드 익셉션은 무조건 try catch 로 감싸줘야 하거나 throw 라는 키워드로 예외를 전파하지 않으면 컴파일 에러가 발생.\n```java\ntry {\n    Thread.slepp(1);\n} catch (InterrupedException e) {\n    // 예외처리    \n}\n```\n- kotlin 에서는 체크드 익셉션을 강제 하지 않는다.\n  - 그러나 원한다면 가능하다.\n  - 자바에서 의미없는 체크드 exception 을 지양하는듯해.\n\n### 기본 자료형\n- 자바는 원시 자료형을 지원하며 객체로된 레퍼런스 타입도 지원한다.\n```java\nint i = 0;\nInteger ii = 0;\nString str = ii.toString();\n```\n- 코틀린은 레퍼런스 타입만 지원한다.\n```kotlin\nval i: Int = 0;\nval str: String = i.toString();\n```\n\n- 코틀린의 레퍼런스 타입은 최적화된 방식으로 컴파일 한다.\n```kotlin\nint i = 0;\nString str = String.valueOf(i);\n```\n\n--\n### 정적멤버\n- 자바는 static 키워드로 정적멤버를 선언한다.\n```java\npublic class JavaClass {\n    static int i = 0;\n    \n    public static void staticMethod() {\n        // ...\n    }\n}\n```\n- 코틀린은 companion object 로 대체\n```kotlin\nclass KotlinClass {\n    companion object {\n        val i: Int = 0;\n        fun function() {\n            // ...\n        }\n    }\n}\n```\n\n### 3항 연산자\n- 자바\n```java\nString animalSound = \"호랑이\".equals(animal) ? \"어흥\" : \"야홍\";\n```\n- 코틀린은 if else 로 대체한다.\n```kotlin\nval animalSound: String = if (\"호랑이\" == animal) \"어흥\" : \"야홍\";\n```\n---\n\n### 세미콜론\n- 자바는 무조건 ; 세미콜론이 붙지만 코틀린은 안붙는다.\n```java\nBoolean isAdmin = userService.isAdmin(userId);\n```\n\n```kotlin\nval isAdmin: Boolean = userService.isAdmin(userId)\n```\n\n# 코틀린에는 있는데 자바에는 없는기능\n### 확장\n- 개발자가 임의로 객체의 함수나 프로퍼티를 확장해서 사용할 수 있다.\n\n```kotlin\nfun String.first(): Char {\n    return this[0]\n}\n\nfun String.addFirst(char: Char): String {\n    return char + this.substring(0)\n}\n\nfun main() {\n    println(\"ABCD\".first()) // 출력 A\n    println(\"ABCD\".addFirst('Z')) // 출력 ZABCD \n}\n```\n\n### 데이터 클래스\n- 데이터를 보관하거나 전달하는 목적을 가진 불변 객체로 사용\n\n```kotlin\ndata class Person(val name: String, val age: Int) {\n    // hashCode(), equals(), toString() 자동생성됨\n    // 이외에도 copy(), componentN 도 유용함.\n}\n```\n\n- 기존 자바에선 주로 lombok 을 사용\n\n```java\n@Getter\npublic class Person {\n    private final String name;\n    private final int age;\n}\n```\n\n```kotlin\n// jdk 15 에선 record 라는 이름이 추가됨\npublic record Person(String name, int age) {\n    \n}\n```\n--\n\n# 문자열 템플릿\n- 문자열에 변수를 사용하거나 여러행으로 된 텍스트 블록을 사용 할 수 있다.\n```kotlin\nval text = \"World\"\nval greeting = \"Hello, ${text}\"\n\nprintln(greeting) // Hello, World\n\n//  문자열 템플릿 기반의 다이나믹 쿼리\nfun sql(nameIncluded: Boolean) =\n        \"\"\"\n          SELECT id, name, email, age \n          FROM users \n          WHERE id = :id ${\n                if (nameIncluded) {\n                  \"\"\"\n                  AND name = :name\n                  \"\"\" \n                } else \"\"\n            }\n        \"\"\"\n```\n\n### 기타\n- 스마트 캐스트 실드 클래스 (Jdk15 추가)\n- 위임\n- 중위 표현식\n- 연산자 오버로딩\n- 코루틴\n- etc\n\n\n# 공식문서\n- https://docs.spring.io/spring-framework/reference/web/webmvc/mvc-servlet.html\n- 공식 문서의 샘플 코드를 보면 kotlin 탭을 제공\n\n![img_1.png](img_1.png)\n\n# Spring initializr\n- 기본 언어로 코틀린을 선택할 수 있고 코틀린인 경우 Gradle Project를 선택하면 빌드 설정 을 기반으로 생성해준다\n- Spring initialzr 를 통해 생성된 build.gralde.kts\n\n```gradle\nimport org.jetbrains.kotlin.gradle.tasks.KotlinCompile\n\nplugins { \n    id(\"org.springframework.boot\") version \"2.6.7\" \n    id(\"io.spring.dependency-management\") version \"1.0.11.RELEASE\" \n    kotlin(\"jvm\") version \"1.6.21\" \n    kotlin(\"plugin.spring\") version \"1.6.21\"\n}\n\ngroup = \"com.example\"\n\nversion = \"0.0.1-SNAPSHOT\"\n\njava.sourceCompatibility = JavaVersion.VERSION_11\n\nrepositories { \n    mavenCentral() \n}\n\ndependencies { \n    implementation(\"org.springframework.boot:spring-boot-starter\") \n    implementation(\"org.jetbrains.kotlin:kotlin-reflect\") \n    implementation(\"org.jetbrains.kotlin:kotlin-stdlib-jdk8\") \n    testImplementation(\"org.springframework.boot:spring-boot-starter-test\") \n}\n\ntasks.withType<KotlinCompile> { \nkotlinOptions { \n        freeCompilerArgs = listOf(\"-Xjsr305=strict\") jvmTarget = \"11\" \n    } \n}\n\ntasks.withType<Test> { \n    useJUnitPlatform() \n}\n```\n\n\n- 코틀린 스프링 프로젝트에서 필수적인 플러그인\n  - kotlin(\"plugin.spring\")\n\n- 코틀린 스프링 프로젝트에서 필수적인 의존성\n  - org.jetbrains.kotlin:kotlin-reflect\n  - org.jetbrains.kotlin:kotlin-stdlib\n\n이외에도 plugin.jpa, jackson-module-kotlin 등 프로젝트를 구성하면서 필요한 플러그인 과 <br/>\n코틀린 의존성이 있고 Springinitialzr에서 프로젝트를 구성할 경우 자동으로 세팅해준다\n\n# 스프링 부트\n```\n@SpringBootApplication class DemoApplication\n\n// fun 탑- 레벨 함수이므로 클래스 바깥에서{ 호출\nmain(args: Array<String>) {\n    runApplication<DemoApplication>(*args)\n}\n```\n\n### @ConfigurationProperties\n- 스프링 애플리케이션에 지정한 설정을 기반으로 설정 클래스를 만들때, <br/>\n  @ConstructorBinding 을 사용하면 setter가 아닌 생성자를 통해 바인딩 하므로 <br/>\n  불변 객체를 쉽게 생성할 수 있다.\n\n```kotlin\n@ConstructorBinding\n@ConfigurationProperties(\"example.kotlin\") \n\ndata class KotlinExampleProperties(\n                val name: String,\n                val description: String,\n                val myService: MyService\n                ) {\n\ndata class MyService(\n            val apiToken: String,\n            val uri: URI\n        )\n\n}\n```\n\n### 테스트 지원\n- 기본 제공되는 Junit5 기반의 테스트를 특별한 설정 없이 그대로 사용이 가능하다\n- 모의 객체를 만들어 테스트하려면 Mockito 대신 MockK를 사용할 수 있다"},{"excerpt":"배포 전략","fields":{"slug":"/deploy-strategy/"},"frontmatter":{"date":"November 18, 2022","title":"배포전략","tags":["배포"]},"rawMarkdownBody":"\n# 배포 전략\n"}]}},"pageContext":{}},"staticQueryHashes":[],"slicesMap":{}}