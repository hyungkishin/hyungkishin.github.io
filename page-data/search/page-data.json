{"componentChunkName":"component---src-pages-search-jsx","path":"/search/","result":{"data":{"allMarkdownRemark":{"nodes":[{"excerpt":"들어가며 1부에서 JS 번들 다이어트를 통해 전체 페이지의 무게를 줄이는 작업을 진행했다 🤔그러나 홈페이지의 성능은 거의 그대로였다.  google Lighthouse 에서 측정 해보면, \"왜 느려 보이는지\", \"어디서 막히는지\", \"어떻게 개선해야 하는지\"를 구체적으로 살펴 볼 수 있다. (겁나 친절한데 ..? 👍) ⚡ Core Web Vitals 지표…","fields":{"slug":"/phase4/"},"frontmatter":{"date":"May 04, 2025","title":"퍼포먼스 최적화 를 향해 - 2부","tags":["front-end","performance","series"]},"rawMarkdownBody":"\n## 들어가며\n1부에서 JS 번들 다이어트를 통해 전체 페이지의 무게를 줄이는 작업을 진행했다  \n🤔그러나 홈페이지의 성능은 거의 그대로였다.\n\n![빨라진것 같은 느낌은.. 합리화 임.](img_1.png)\n\ngoogle Lighthouse 에서 측정 해보면, \"왜 느려 보이는지\", \"어디서 막히는지\", \"어떻게 개선해야 하는지\"를 구체적으로 살펴 볼 수 있다.    \n(겁나 친절한데 ..? 👍)\n\n## ⚡ Core Web Vitals\n\n| 지표명 (약어)                           | 설명                       | 일상 비유                             |\n| ---------------------------------- | ------------------------ | --------------------------------- |\n| **CLS** (Cumulative Layout Shift)  | 화면이 로딩 중 갑자기 밀리거나 이동한 정도 | 버튼을 누르려는데 갑자기 밑으로 밀려서 광고 클릭한 상황 |\n| **SI** (Speed Index)               | 화면이 시각적으로 완성되는 속도        | 영화 시작할 때 화면이 빠르게 차오르는 느낌          |\n| **FCP** (First Contentful Paint)   | 첫 텍스트나 이미지가 뜨는 시점        | 영화 타이틀이 처음 뜨는 순간                  |\n| **LCP** (Largest Contentful Paint) | 메인 이미지나 큰 텍스트가 완전히 보일 때  | 표지부터 다 읽고 본문 읽을 준비 완료             |\n| **TBT** (Total Blocking Time)      | JS가 렌더링을 막은 총 시간         | 문 열고 들어가려는데 안에서 JS 처리 중이라 안 열리는 상황 |\n\n## 개선 목표\n**✅ CLS (Cumulative Layout Shift)**  \n**✅ FCP (First Contentful Paint)**  \n**✅ TBT (Total Blocking Time)**  \n\n## 👀 CLS\nCLS 의 **핵심** 은 **“보이는 걸 미리 예고하고, 갑자기 바꾸지 않는다”** 이다.\n\n현재 운영중인 사이트에서, CLS 문제는 대부분 이미 알고는 있지만 실전에서 놓치기 쉬운 것들.    \n대표적으로 CLS 점수를 깎아 먹는 주요 원인은 Taboola 라는 광고 위젯.  \n\nTaboola는 초기엔 비어 있다가 스크립트 로딩 이후에 콘텐츠가 삽입되는데,  \n이때 높이를 미리 잡아두지 않으면 아래 콘텐츠들이 순식간에 밀려나며 CLS가 발생한다.      \n\n> 마치 의자에 앉으려고 했는데, 뒤로 밀려서 엉덩방아 찍은 느낌이다. ( 오늘 일임 )\n\n| 문제 요소                    | 설명                                                                       |\n| ------------------------ | ------------------------------------------------------------------------ |\n| ❌ 이미지/광고 영역의 크기 미지정      | `<img>`나 광고 `<div>`에 `width`, `height`, 또는 `aspect-ratio`가 없어 로딩 후 밀림 발생 |\n| ❌ 비동기 렌더링 컴포넌트           | `dynamic(import(...))`, `<Suspense>` 등을 통해 불쑥 나타나는 컴포넌트로 인해 레이아웃 밀림 발생   |\n| ❌ navigation 메뉴/헤더 애니메이션 | fixed 헤더가 transition으로 등장하면서 콘텐츠를 아래로 밀어냄                                |\n| ❌ 웹폰트 로딩 지연           | FOIT/FOUT 현상으로 텍스트 표시가 밀려 CLS 유발             |\n| ⚠️ 광고/소셜 위젯 로딩 지연        | GPT 광고, Interplay, Taboola 등 외부 위젯이 나중에 등장하면서 전체 구조가 밀림                  |\n\n이런 문제를 해결하는 가장 확실한 방법은, 비동기 렌더링 컴포넌트의 높이를 미리 지정해 콘텐츠의 위치를 예고하는 것이다.\n\n그리고 광고 영역은 Lazy Load로 처리해, 일정 스크롤 이후에 렌더링되도록 하는 것이 핵심 !  \n\n### ❗비동기 렌더링 컴포넌트\n비동기 컴포넌트는 렌더링 시점까지 공간을 차지하지 않기 때문에, 아래 콘텐츠가 갑자기 밀려버릴 수 있다.\n예를 들어 dynamic(import(...)), <Suspense>로 로딩되는 컴포넌트는 로딩 중에 명확한 높이 또는 placeholder 가 없다면 layout shift 를 유발한다.\n\n외부 컴포넌트(TodayTopStories, 댓글, 추천 콘텐츠 등)는 특히 레벨이 높은 CLS 유발 요인이다. ( 제일 맛도리다. )\n\n```js\nimport dynamic from \"next/dynamic\";\nimport { Skeleton } from \"@/components/Skeleton\";\n\n// dynamic 컴포넌트 로딩 시 Skeleton 사용\nconst RelatedStories = dynamic(() => import(\"./RelatedStories\"), {\n    ssr: true,\n    loading: () => <Skeleton />,\n});\n\n// Suspense 사용 시, fallback에 고정 높이 지정\n<Suspense fallback={<div style={{ minHeight: 400 }}><Skeleton /></div>}>\n    <RelatedStories articleId=\"abc123\" />\n</Suspense>\n\n```\n\n> ⚠️ 주의   \n> <Skeleton /> 컴포넌트 자체가 min-height 또는 fixed height를 갖지 않는다면 의미가 없다.  \n> fallback 은 시각적 장식이 아니라 레이아웃 안정장치라는 점을 명심해야 한다.\n\n## ⏰ Lazy Load\n예를 들어 뉴스 기사 하단의 댓글 영역, 추천 콘텐츠, Taboola 광고 등은 반드시 초반에 보여줄 필요가 없다.    \n\nLazy Load 대상으로 적합하고, 아래는 이를 위한 `LazyShow` 유틸 컴포넌트 예시다.    \n\n```js\n\"use client\";\n\nimport { useEffect, useRef, useState } from \"react\";\n\ninterface LazyShowProps {\n  children: React.ReactNode;\n  rootMargin?: string;\n  threshold?: number;\n  once?: boolean; // 한번만 보여줄지\n}\n\nexport const LazyShow = ({ children, rootMargin = \"200px\", threshold = 0.1, once = true }: LazyShowProps) => {\n  const ref = useRef<HTMLDivElement>(null);\n  const [isVisible, setIsVisible] = useState(false);\n\n  useEffect(() => {\n    if (!ref.current) return;\n\n    if (!(\"IntersectionObserver\" in window)) {\n      // Safari 구버전 대비 fallback\n      setIsVisible(true);\n      return;\n    }\n\n    const observer = new IntersectionObserver(\n      ([entry]) => {\n        if (entry.isIntersecting) {\n          setIsVisible(true);\n          if (once) {\n            observer.disconnect();\n          }\n        } else if (!once) {\n          setIsVisible(false);\n        }\n      },\n      { rootMargin, threshold }\n    );\n\n    observer.observe(ref.current);\n    return () => observer.disconnect();\n  }, [rootMargin, threshold, once]);\n\n  return <div ref={ref}>{isVisible ? children : null}</div>;\n};\n```\n\n결국 CLS 방지는 “언제 어디서 무엇이 렌더링될지”를 브라우저에게 미리 알려주는 것이다.  \n예측 가능한 레이아웃만이 안정적인 사용자 경험을 만든다.  \n\n> **비동기로 로딩되더라도, 언제 어디서 어떤 높이로 들어올지 예고**  \n> **중요한 콘텐츠가 아닌경우 Lazy Load !**\n\n## 😶‍🌫️ FCP\nFCP는 사용자가 페이지에서 **\"첫 번째 콘텐츠(텍스트, 이미지 등)를 보는 순간까지의 시간\"** 을 의미한다.  \n\n즉, 페이지가 뜨긴 떴는데 아무것도 안 보이는 상태가 길어질수록 FCP 점수는 나빠진다.    \n위쪽 영역(Above the Fold) 콘텐츠를 최대한 빨리 보여주는 것이 핵심 POINT.\n( 이미지든 텍스트든, 뭐든간에 첫 화면이 빠르게 보이면 점수가 좋아진다. )\n\n| 문제 요소                   | 설명                                                   |\n|-------------------------|------------------------------------------------------|\n| ❌ 이미지 용량이 큰 경우          | 상단 이미지를 lazy 처리하면 실제 첫 시각 요소가 늦게 등장함                 |\n| ❌ JS 의존형 컴포넌트           | `hydrate` 이후에 렌더링되는 컴포넌트 의 경우, 초기 화면엔 보이지 않음         |\n| ❌ 웹폰트 지연 로딩 (FOUT/FOIT) | 커스텀 폰트가 늦게 적용되며 텍스트 위치가 늦게 나타남                       |\n| ❌ 초기 데이터 비동기 처리         | `useEffect`에서 데이터 fetch 이후, 첫 화면 렌더링이 지연됨            |\n| ❌ 너무 많은 요소 한꺼번에 렌더링     | 초기 화면에서 꼭 보여야 할 핵심 콘텐츠조차 뒤늦게 등장하거나, 렌더링 경쟁에 밀려버리는 문제 |\n\n그런데, CLS 를 처리하면서 FCP 점수도 덩달아 오르는것을 확인할 수 있었다.  \n> 많은 요소를 한꺼번에 렌더링하지 않고 사용자가 보는 뷰포트에 맞는 컴포넌트만 랜더링 하기 때문 \n\nFCP 의 경우는 사용자가 처음 보는 콘텐츠가 얼마나 빨리 보이느냐의 문제다.\n\n## 🚫 TBT\nBT는 JS가 렌더링을 막고 있는 시간을 말한다.  \n코드 스플리팅, 불필요한 JS 제거, 그리고 불필요하게 SSR로 처리되던 인터랙티브한 위젯들 (ex. 댓글, 공유 모듈)\n\n이 문제들을 해결하기 위해, 상단은 SSR 하단은 `LazyShow`, `dynamic(import(...))`을 활용해 랜딩 시점을 뒤로 미루고 나니  \n\nTBT는 **0ms**로 떨어졌다.\n\n## Light House 를 돌려보자\n\n![CLS 와 TBT, FCP 가 개선됨](img.png)\n\n## 추가로 개선 할 부분\n이제 남은 성능 요소는 LCP 와 SI 만 남은 상태이다.\n\n"},{"excerpt":"들어가며 웹페이지가 빠르지 않으면, 유저는 기다려주지 않는다. 특히 뉴스/언론 사이트처럼 콘텐츠 소비가 빠르게 이루어지는 환경에서는 더더욱 그렇다.   네트워크 텝을 열어보니 JS 가 프로젝트 사이즈에 비해 많은 용량을 차지하고 있었다. 그래서 가장 먼저 손을 댄 건 JS 번들 다이어트. JS 번들의 크기가 클 수록 Core Web Vital 의 TBT …","fields":{"slug":"/phase3/"},"frontmatter":{"date":"May 03, 2025","title":"퍼포먼스 최적화 를 향해 - 1부","tags":["front-end","performance","series"]},"rawMarkdownBody":"\n## 들어가며\n웹페이지가 빠르지 않으면, 유저는 기다려주지 않는다.  \n특히 뉴스/언론 사이트처럼 콘텐츠 소비가 빠르게 이루어지는 환경에서는 더더욱 그렇다.  \n\n네트워크 텝을 열어보니 JS 가 프로젝트 사이즈에 비해 많은 용량을 차지하고 있었다.\n\n그래서 가장 먼저 손을 댄 건 JS 번들 다이어트.   \nJS 번들의 크기가 클 수록 Core Web Vital 의 TBT 성능에도 영향을 주는데, 한마디로 main Thread 가 일을 너무 많이 하는 바람에 UI 를 그리기 힘들어 할 수 있다.  \n\n그래서 사용되는 JS Library 들이 TreeShaking 잘 되고 있는지, 총 bundle 의 크기가 어떻게 되는지 파악 이 필요했다.\n\n✅ 개선 목표\n- JS bundle 점검 및 개선\n  - TreeShaking\n  - 불필요 library 다이어트\n\n---\n\n## JS 번들을 정검 해보자\n\n```bash\n\n$ yarn add -D @next/bundle-analyzer\n```\n\n그런다음 next.config.js 에서 analyzer 를 활성화.\n```js\n\n\nimport createBundleAnalyzer from \"@next/bundle-analyzer\";\n\n// ...\n\nconst withBundleAnalyzer = createBundleAnalyzer({\n    enabled: process.env.ANALYZE === \"true\",\n    openAnalyzer: false,\n});\n\n// ... \n\nexport default withBundleAnalyzer(nextConfig);\n```\n\npackage.json script 부분역시, 명령어 활성화 필요. \n\n```js\n\"script\": {\n ... \n  \"analyze\": \"ANALYZE=true next build\", \n  \"analyze-explorer\": \"source-map-explorer '.next/static/chunks/*.js'\",\n ...\n}\n \n```\n\n먼저 어떤 라이브러리들이 번들에 포함되어 있는지 확인하기 위해 bundle-analyzer 를 설치해 주고 분석해 보니, lodash-es 와 moment-timezone 이 포함되어 있었다.\n700KB 와 500KB 먹음직 스럽게 제거할 수 있는 크기였다.\n\n![프로젝트 내 js 번들 결과](img_1.png)\n\n \n## 📦 lodash 최적화\n\n프로젝트 내에서 lodash-es가 설치되어 있었고, 실제 사용하는 함수는 debounce 하나뿐이었다.  \n아마도 Tree Shaking을 노리고 lodash-es를 선택했던 것 같다.   \n\n> tree shaking 이란 ?\n> 실상 쓰는 코드만 번들에 포함시키고, 안 쓰는 코드를 제거하는 기능인 Tree Shaking\n\n하지만 애석하게도, lodash-es는 ESM 구조이다.  \nTree Shaking이 가능하다고 알려져 있지만, 내부적으로 많은 공통 유틸 함수들이 함께 import되기 때문에,     \ndebounce 하나만 불러와도 수많은 내부 의존성 코드가 함께 번들된다.  \n\n즉, 다음과 같은 코드 는 실제 번들 사이즈를 눈에 띄게 줄이지 못한다.\n```js\nimport { debounce } from \"lodash-es\";\n```\n\n함수 단위 패키지로 대체 가 가능한 lodash 로 변경하기로 결정하였다.  \n개별 모듈(함수)로 쪼개서 npm 패키지를 배포하고, 무었보다 monorepo로 관리하기 때문에 효과적으로 다이어트가 가능하다고 판단했다.  \n\nlodash.debounce를 import하려면 lodash.debounce 패키지를 따로 설치해야 하고,  \n타입스크립트 환경에서는 타입 정의 패키지(@types/lodash.debounce)도 필요하다.\n\n```bash\n\n$ yarn add lodash.debounce\n\n$ yarn add -D @types/lodash.debounce\n````\n\n최소한의 코드만 번들에 포함되고, 사용방법은 다음과 같다.\n\n```js\nimport debounce from \"lodash.debounce\";\n```\n\n## ⏰ moment-timezone 최적화 \n\n앞서 말한 것 처럼 lodash는 함수별로 npm 패키지가 분리되어 있거나, ES 모듈 구조라서 개별 함수만 import할 수 있지만,   \nmoment/moment-timezone 는 하나의 큰 번들(모듈)로 배포되고 내부적으로 모든 기능이 단일 객체(moment)에 결합되어 있다.\n\n죽, moment-timezone은 하나의 큰 번들이고, 부분 import 안 된다.. 구조 상 ESM도 아니고, 트리셰이킹도 불가능.\n\n```js\nimport { tz } from \"moment-timezone\"; <- ❌\nimport moment from \"moment/timezone\"; <- ❌\n```\n\n구버전 브라우저(특히  Edge, 구형 크롬/파이어폭스 등)까지 완벽히 커버하면서, 타임존 목록 및 오프셋, 타임존 변환 등 기능을 제공하려면  \nmoment-timezone을 계속 사용하는 것이 가장 안전한 선택이라.. 이대로 두기로 하였다. ( 언론 뉴스 페이지다 보니, 해외 구형 디바이스 까지 커버 해야 한다. )  \n\nmoment-timezone은 오래된 브라우저까지 호환성을 고려해 설계되어 있다 (IE9 이상, 구형 모바일 브라우저 등 포함)\n최신 방식인 Intl.supportedValuesOf('timeZone')는 최신 브라우저(크롬 104+, 사파리 16.4+ 등)에서만 지원되고  \n구버전 브라우저에서는 동작하지 않는다.\n\n굳이 하려면, 데이터 범위를 줄여서 번들 사이즈를 최적화 하는게 유일한 방법이다.   \n\n```bash\n\n# slim 빌드 사용\n$ npx moment-timezone-data-builder --zones=\"Asia/Seoul\" --start-year=1990 --end-year=2026 > data/packed/latest.json\n```\n\n## 영혼까지 끌어모아 다이어트\n추가적으로 next.config.js 내부 설정중 optimizePackageImports 를 사용하면 소위말해 조금 더 영끌 다이어트를 할 수 있다.  \n\ndate-fns, moment, swiper 같은 덩치 큰 라이브러리에서 \"쓰는 것만 가져오도록\" 자동 변환해줘서 번들 크기를 줄여준다. ( 아 물론 lodash-es 는 효과가 미미...)  \n```js\n\nexperimental: {\n  optimizePackageImports: [\"moment-timezone\", \"date-fns\", \"react-share\", \"swiper\"],\n   ...\n},\n```\n\n## ✨ 결과 ✨  \n3.11 MB -> 2.38 MB 로 줄어들었다.  \n\n![before](img_2.png)  ➡️\n![after](img_3.png)\n\n드라마틱 한 다이어트는 아니지만, 약 23.5% 감소로 인해 실제 웹 성능에선 체감 가능한 수준 으로 보인다.  \n\n\n느린 네트워크, CPU 환경에서 0.7MB 감소는 LCP, TTI에 직격 영향을 줄 수 있고,  \nJS는 CPU cost가 높아서 압축되어도 실행 비용이 크다.  \n\nJS 줄이기만 해도 LCP, FID, CLS 등 모든 항목에 긍정적 영향 을 준다.  \n게다가 3G 환경에선 700KB는 수 초 차이로 이어질 수 있다.  \n\n( 현재 도메인 유저에는 해외 사용자가 많고, 구형 디바이스 유저도 많다. )\n\n운영 중에는 예상치 못한 상황이 자주 발생하고,  \n신규 페이지나 기능을 급하게 작업할 때는 라이브러리 도입을 신중히 검토하기 어려운 경우도 많다.\n\n하지만 작은 습관 하나 *즉, 도입하는 라이브러리의 실제 용도와 비용을 점검하는 습관* 만으로도,\n나중의 **리팩토링 부담과 전체 성능 저하** 를 막는 데 큰 도움이 된다.\n\n업무가 바쁘더라도 관성적으로 아래와 같은 체크리스트를 갖고 움직이자\n- 🤔 이 라이브러리는 정말 필요한가?\n- 🤔 동일 기능을 기존 유틸로 구현할 수는 없을까?\n- 🤔 ESM 구조이거나 트리셰이킹이 가능한가?\n- 🤔 스타일(CSS)이나 다른 의존성을 암묵적으로 같이 끌고 오지 않는가?\n\n> 조금만 습관을 들이면, 성능을 깎아먹는 '무심한 도입'을 줄일 수 있다.\n\n## 결론\nJS 번들 최적화는 단순히 용량을 줄이는 일이 아니다.\n사용자 경험, Core Web Vitals, SEO 성능에까지 직결되는 제품 품질의 핵심이다.\n\n개발 속도와 마감 기한에 쫓기다 보면, 무심코 라이브러리를 도입하고 의존성을 늘리기 쉽다.\n하지만 작은 습관 하나—\"진짜 필요한가?\" 라는 질문만으로도 많은 비용을 아낄 수 있다.\n\n- ✅ 정기적으로 번들 사이즈를 분석하고\n- ✅ 라이브러리 도입 전 체크리스트를 습관화하며\n- ✅ 팀 차원에서 도입 가이드라인을 마련해두자.\n\n"},{"excerpt":"들어가며 AMP 페이지가 동작하지 않았던 이유는 NextJs 에서 지원하지 않은 Router 방식임을 확인.\nPages 디렉토리를 생성후, 하위에 amp 전용 페이지를 두는것으로 진행하기로 했다. 기사 본문의 내용은 기자님들이 별도 도메인에서 Editor로 작성한 본문이 string 형태로 DB 에 적재되니 응답 string 을 dom 으로 뿌려주면 되는…","fields":{"slug":"/phase2/"},"frontmatter":{"date":"May 01, 2025","title":"🏗️ AMP 페이지 개발","tags":["front-end","performance","series"]},"rawMarkdownBody":"\n## 들어가며\nAMP 페이지가 동작하지 않았던 이유는 NextJs 에서 지원하지 않은 Router 방식임을 확인.\nPages 디렉토리를 생성후, 하위에 amp 전용 페이지를 두는것으로 진행하기로 했다.\n\n기사 본문의 내용은 기자님들이 별도 도메인에서 Editor로 작성한 본문이 string 형태로 DB 에 적재되니 응답 string 을 dom 으로 뿌려주면 되는 문제. \n\nAMP(Accelerated Mobile Pages)는 빠른 모바일 페이지 로딩을 위해 구글이 주도한 프레임워크로, **강력한 성능을 얻는 대신 엄격한 제약**을 동반한다.\n\nNext.js에서도 AMP를 적용하려면 이 제약을 그대로 수용해야 하며, **페이지 구조, 스타일링, JS 사용 방식 등에서 별도의 대응이 필요하다.**\n\nNext.js에서 AMP를 적용할 때도 이러한 제한이 그대로 적용된다.\n\n시작 하기전에 기합 넣고 ! \n\n![가보자고](img_3.png)\n\n--- \n\n## TODO LIST 체크\n- ✅ AMP 페이지 는 총 N Phase 로 배포 \n  - ( 우선 amp 가 존재 하는것을 mvp 목표로 배포 ! )\n- ✅ Pages Router 기반의 디렉토리 구조 설계\n- ✅ AMP 대상 페이지 컴포넌트 설계\n- ✅ middleware.ts 에서 /amp 로 시작하는 URL을 감지하여, 해당 페이지를 AMP 페이지로 리다이렉트 하도록 설정\n- ✅ 스타일링 ( GPT 의 도움으로 스피드하게 해결 )\n- ✅ 본문내용 api call 이후 제약 태그 -> amp 태그로 변환 util 만들기\n- ✅ SEO 메타 태그 ( 손으로 일일히 해도 되지만 AI 이용해서 검수정도로만 빨리 ! )\n\n## 되짚고 넘어가는 제약 사항\n⚠️ AMP는 일반적인 React 환경과 달리 다음과 같은 제한이 있다\n\n☝️. **React Hook 사용 제한**  \n- `useEffect`, `useState` 등 hook 기반 로직 사용 불가\n\n✌️. **Sass/SCSS 등 외부 스타일 방식 제한**  \n- 모든 스타일은 inline 또는 제한된 CSS 내에서 처리해야 함\n\n🫰. **일반 script 태그 사용 불가**  \n- `<script>` 태그 자체를 금지하며, JS는 `amp-script`로 제한적으로만 허용됨\n\n> 전체 AMP 검증은 [AMP Validator](https://validator.ampproject.org/) 를 통해 실시간 확인 가능\n\n---\n\n## 🗂️ 디렉팅 구조 전략\npages 디렉토리 를 기반으로 amp 디렉토리를 생성하고, 하위에 slug 페이지를 작성한다.\n\n> 🔖 slug 란 ?\n> - ex ) /news/2025/04/17/기사제목\n> - URL의 일부를 사람이 읽기 좋고 검색엔진 친화적으로 만든 문자열\n\n\nmiddleware.ts 에서 /amp 로 시작하는 URL을 감지하여, 해당 페이지를 AMP 페이지로 리다이렉트 하도록 설정.\n\n![디렉토리 뼈대](img.png)\n```text\n \n📁 src\n|── components                     \n    ├── amp                        👈 amp 페이지 내 공통컴포넌트 ( Header, Body, Footer 등 재사용 컴포넌트들 쭉쭉 넣어주고 ~ )\n    |... 원래 있던 친구들 내비두고 ~\n├── pages                         \n│   ├── amp                        👈 AMP 페이지 전용 디렉토리\n│   │   └── [slug].tsx             👈 section 카테고리별 디렉토리\n|   |     └── [depth1].tsx         👈 amp depth 1 본문 페이지\n|   |         └── [depth2].tsx     👈 amp depth 2 본문 페이지\n|   |             └── [depth3].tsx 👈 amp depth 3 본문 페이지\n```\n\n이렇게 되면 사실상 **사용자 관점** 에서 보이는 기사 뷰 페이지는 2벌이다.\n- 일반 페이지 [ PC / MO ] <-- 다행이 반응형으로 통합되어 있어서 아멘...\n- AMP 페이지 ( depth 별 )\n\n기존 기사 본문 URL 구조는 **slug url** 형식으로 되어있으니 amp 페이지로 유입될 경우 본문에 해당되는 amp 페이지로 redirect 해주면 된다 \npages 만 UI 뼈대를 만든 후 공통화 컴포넌트화 시키면 되겠다.\n\n![기사 본문 상단 구조](img_1.png)\n\n> AMP는 제약은 많지만, 뉴스 도메인에선 여전히 유의미하다\n> \n> React hook이나 script 사용은 어렵지만 기본 콘텐츠 위주 뉴스 페이지엔 큰 무리는 없다\n> \n> middleware.ts + slug 기반으로 AMP 라우팅 처리하면 깔끔하게 대응 가능\n> \n> AMP 페이지는 별도로 구성하되, 디자인/구조는 최대한 기존과 일치시키는 전략이 효과적이다\n\n## 기사 본문에서 amp 태그로 변환하는 util 함수 만들기 \n- 일반 HTML 태그는 사용 불가, AMP 전용 태그만 사용 가능\n- 예를 들어, `<img>` 태그는 `<amp-img>`로 대체해야 하며, `<script>` 태그는 `<amp-script>`로 대체해야 한다\n- `<style amp-custom>` 태그에는 **최대 50KB까지만** CSS 작성 가능\n- 애니메이션 전용으로 허용된 `<style amp-keyframes>`는 **최대 500KB까지** 허용되지만,\n  이는 `<body>` 하단에만 위치할 수 있고, 오직 키프레임 규칙만 작성 가능하다\n- JS 이벤트 핸들러 제거 , javascript: 링크 제거 \n- 허용되지 않는 태그 하위 호환\n  - font, area, form\n\n👉 **총 CSS + 인라인 스타일 합산이 75KB를 넘지 않도록** 주의해야 한다 - [ 관련 공식문서 ](https://amp.dev/documentation/guides-and-tutorials/learn/spec/amphtml)\n\n---\n\n## ⚡️ 대략 적인 AMP 페이지 구조 ( 보여줄 수 없어서 추상적으로 대체 )\n```html\n<!DOCTYPE html>\n<html ⚡>\n\n  <!-- 공통 대상 Header -->\n  <head>\n    <meta charset=\"utf-8\">\n    <meta name=\"viewport\" content=\"width=device-width,minimum-scale=1,initial-scale=1\">\n    <link rel=\"canonical\" href=\"원본 URL 잘 집어넣어야 합니다.\">\n    <meta name=\"amp-google-client-id-api\" content=\"googleanalytics\">\n    \n    <!--  공통 대상 : Style  -->\n    <style amp-custom>\n      /* AMP 전용 CSS 들어올 자리 ( 용량 50KB 안넘기게 살살 다뤄줘 ) */\n    </style>\n    \n  </head>\n  \n  <body>\n    \n    <!--  공통 대상 : 뉴스 기사 Body -->\n    <main>\n      <!--  공통 대상 : 예쁘게 컴포넌트 화 -->\n      <article>\n        기사 본문이 들어갈 자리\n      </article>\n      \n      <!--  갖가지 광고 예쁘게 공통으로 말아 -->\n      <ad>\n        광고 들어갈 자리 Lazy Load 적용 대상\n      </ad>\n      \n    </main>\n    \n    <!--  공통 대상 : footer 야 뭐...  -->\n    <footer>푸터 들어갈 자리</footer>\n  </body>\n</html>\n```\n\n---\n\n## AMP 규칙에 맞는 Style \n\nAmp 용으로 style 잡는게 좀 까다로웠다 ( sass 방식이 왜 안돼 ... 하나하나 분석하다가 이건 도저히 아니다 싶었다. )\n\nAMP는 `<style amp-custom>` 단 하나만 허용\n- 모든 사용자 정의 스타일은 `<head>` 안의 `<style amp-custom>` 안에 작성해야 함.\n- `<style>` 태그가 두 개 이상 있으면 AMP 유효성 검사에서 실패. ( 별 ... )\n- 총 CSS 용량은 75KB 이하\n- CSS 속성은 inline 스타일로 작성해야 함. ( CSS-in-JS 방식은 사용 불가 )\n  - `<style amp-custom>` 내부 전체 CSS 크기 합이 75KB (75,000 bytes)를 넘으면 안 됨.\n- 초과 시 AMP validation 실패 → 페이지 노출 불가.\n\n미지원 CSS 속성/기능\n- @import 사용 불가 ❌ \n- !important 사용 불가 ❌\n- position: fixed는 예외적으로 일부 AMP 컴포넌트에서만 허용 (ex. <amp-sidebar>)\n- animation, keyframes는 제한적으로만 허용됨 \n- filter, backdrop-filter, mix-blend-mode 등 일부 CSS 속성 사용 불가.\n\nAMP 구성요소의 스타일링\n- `<amp-img>`,`<amp-carousel>`, `<amp-sidebar>` 등 AMP 컴포넌트는 반드시 지정된 방식으로 스타일링해야 함.\n- 특히 layout=\"responsive\" 등 AMP layout 시스템에 맞는 설정 필수.\n\n---\n\n## 대망의 1차 배포 성공 🏰\n검색 색인과 AMP 페이지 1차 반영 이후 구글 유입이 조금씩이나만 바로 잡혀가는 모습이 너무 보기 좋다.\n\n![어서오세요 :)](img_4.png)\n\n![google search console](img_2.png)\n\n구글 Search Console 에서 AMP 메뉴를 확인하니, Google Amp validator 검증에 실패해,     \n유효하지 않은 페이지로 판단해 노출하지 않은 모양이다.\n\n![안되는 이유가 있지..](img_5.png)\n\n누락된 허용하지 않은 태그, 미디어 속성의 태그에 src 가 https 가 아닌 http 가 존재하거나,  \n<기사이름> 이런식의 태그가 아닌데 태그라고 오 인식하는 문제가 있었다.  \n\n( 이미지 혹은 뷰어 용 태그에 src 는 https 가 아니라 http 로 되어있는 부분은 server 에서 처리가 필요 ) \n\n> 이걸 어떻게 표준화 할까 ...?\n\n---\n\n## 🤔 라이브러리를 안 쓰고 처리 할 수 없었을까 ?\n\nDOMParser 를 쓸 수 없었다. \n브라우저 런타임에서만 동작하는 Web API 이고, Next.js의 서버 사이드 코드(SSR), 즉 Node.js 환경에서는 사용할 수 없다.\n\n기사 본문은 **서버 사이드 데이터 페칭** 시점에 가져온다. 그래서 amp guide 에 맞는 dom 으로 변환하는 util 함수 내에,  \n기사 본문을 amp guide 에 맞는 정규식으로 치환하거나 제거하는 방식으로 진행했더니 너무 위험했다.  \n\n(기사 본문 내용이 틀어지거나, inline Style 이 깨지거나 ... 보여야 할 내용이 일부분 사라지거나 ...)\n\n| 작업 예시                          | 라이브러리 없이 가능? | 설명                        |\n| ------------------------------ | ------------ | ------------------------- |\n| `<img>` → `<amp-img>` 변환       | 🔴 어려움       | HTML 구조 파싱이 필요, 정규식으론 불안정 |\n| `<iframe>` → `<amp-iframe>`    | 🔴 어려움       | 조건 분기 및 속성 매핑 복잡          |\n| `onClick`, `onMouseOver` 속성 제거 | 🔶 가능하지만 복잡  | 수백 개 태그 모두 순회해야 함         |\n| 불필요한 태그 제거 (`<font>`, `<map>`) | 🔶 가능하지만 비효율 | 정규식 + 수작업으로 불안정           |\n| 최종 HTML 문자열로 재조립               | 🔴 위험        | 구조 깨질 확률 높음               |\n\n\n이 과정에서 여러 라이브러리를 도입했는데, 목표는 다음과 같았다.  \n\n- HTML 태그를 파싱해서 변형하거나 제거하는 작업이 필요하다.\n- 따라서, DOM을 조작할 수 있는 라이브러리가 필요하다.\n\n---\n## 🧩 라이브러리 도입 결정\n\n✅ cheerio — DOM 파싱의 사실상 업계 표준 \n\nAMP 변환의 핵심은 Google GuideLine 에 허용되지 않는 HTML 태그를 파싱해서 변형하거나 제거하는 작업이 필연적인데,  \n이때 cheerio는 서버 사이드에서 jQuery처럼 HTML을 다룰 수 있는 경량 라이브러리로, 아래 작업들을 편하게 처리할 수 있었다.\n\n사용법은 아래 예시 로.\n```jsx\nconst $ = cheerio.load(html);\n$(\".writer\").remove(); // 불필요한 요소 제거\n$(\"img\").each(...);    // 이미지 태그 변환\n```\n\n> 📌 대안은?  \n> jsdom도 있었지만, 성능과 문법의 직관성에서 cheerio가 더 낫다고 판단.  \n> - ( 훨씬 무겁고, DOM 구현이 브라우저 수준이지만, cheerio보다 느림 )  \n> 단순한 조작에는 cheerio가 가장 적합하다.  \n\n✅ isTag (from domhandler) — 안정성 있는 노드 필터링  \n\n모든 DOM 노드가 태그는 아니기 때문에, cheerio(\"*\").each(...) 루프를 돌릴 때는 노드 타입 검사를 해줘야 한다.  \n이때 isTag()를 사용하면 안정적으로 태그 여부를 확인할 수 있다.  \n\n```js\nif (isTag(el)) {\n    // 태그일 때만 속성 제거\n}\n```\n\n⚠️ image-size + fetch  \n\n별도 설치가 필요했던 라이브러리는 아니지만 안정성과 성능 사이의 고민이 존재했다.  \n\nAMP에서는 <amp-img>에 반드시 width와 height가 있어야 한다.  \n그런데 컨텐츠에 이 정보가 누락된 경우도 있어서, 서버에서 이미지를 직접 fetch하고 image-size로 크기를 추출할 필요가 있었다.  \n\nimg 태그에 크기를 알 수 없는 경우 별도로 호출하기로 하였다. \n\n```js\nconst res = await fetch(src);\nconst buffer = new Uint8Array(await res.arrayBuffer());\nconst { width, height } = imageSize(buffer);\n\n```\n\n이 방식은 어떤 이미지든 깨지지 않게 하려는 의도는 있으나, 단점도 존재한다.\n- SSR 성능 저하 가능성 (네트워크 fetch + 버퍼 파싱)\n- 이미지 수가 많아질수록 병목 현상 발생\n\n> 그러나, 최근 기사 editor 에서 이미지 크기를 지정하는 경우가 대부분 이며,\n> \n> 오래된 기사의 경우에만 이미지 크기가 표기 되어있지 않아 (width, height), 해당 이슈에 대해서 공유를 드렸다.\n> \n> 이미지 의 크기를 알 수 없는 경우에만 코드레벨에서 조건을 분기하였다.  \n> ( 서버에서 이미지를 직접 fetch하고 image-size로 크기를 추출하는 방식 )\n\n---\n\n## 마무리 \n![아... 영롱해](img_6.png)\n\nAMP 페이지 는 성능과 사용자 경험을 고려할 때 여전히 유용한 기술이다.  \n정리하면 다음과 같다.\n\n- Next.js에서 지원하는 기능이지만, 제약이 많아 사용하기 어려운 경우가 많다.\n  - Guide 에 맞는 HTML 태그를 파싱하고 변형하는 정교한 작업이 필요하다. ( 물론 트레이드 오프는 있다. )\n  - 이때 cheerio와 isTag를 사용하면 안정적으로 작업할 수 있다.\n- 성능과 사용자 경험을 고려할 때 여전히 유용한 기술이다. ( 도메인 특성에 맞게 사용함이 핵심. )\n- 제약을 잘 이해하고, 필요한 라이브러리를 적절히 활용해야 한다."},{"excerpt":"들어가며 현재 한 언론사에서 뉴스 웹사이트 운영과 성능 최적화를 진행하고 있다.   뉴스 기사의 검색 노출 최적화는 단순한 트래픽을 넘어 광고 수익과 직결된다. 요즘 대부분의 사용자는 뉴스를 포털보다는 검색을 통해 소비하며,\n특히 모바일 사용자의 70% 이상은 검색 결과 상단에서만 기사를 클릭한다. 아래로는 거의 내려가지 않기 때문에, 검색 결과 2페이지…","fields":{"slug":"/phase1/"},"frontmatter":{"date":"April 17, 2025","title":"🗞️ 한 달간의 뉴스 사이트 프론트 성능 최적화✨","tags":["front-end","performance","series"]},"rawMarkdownBody":"\n![이미지 출처 - 한국일보](img.png)\n\n## 들어가며\n현재 한 언론사에서 뉴스 웹사이트 운영과 성능 최적화를 진행하고 있다.  \n\n뉴스 기사의 **검색 노출 최적화**는 단순한 트래픽을 넘어 **광고 수익**과 직결된다.\n\n요즘 대부분의 사용자는 뉴스를 포털보다는 검색을 통해 소비하며,\n특히 모바일 사용자의 70% 이상은 검색 결과 상단에서만 기사를 클릭한다.\n\n아래로는 거의 내려가지 않기 때문에, 검색 결과 2페이지에 있는 기사는 사실상 묻힌다고 봐도 된다.\n\n수많은 뉴스 매체들이 같은 이슈를 거의 동시에 다루는 상황에서 검색 결과에 잘 노출되기 위해서는, **'누가 먼저, 더 빠르게, 더 안정적으로 노출되느냐'** 가 실시간 트래픽의 성패를 가른다.\n   \n웹사이트의 \"속도\"가 빠르고 사용자 경험이 좋아야 한다.\n\n구글은 이를 수치화해서 측정할 수 있도록 ‘Core Web Vitals’라는 성능 지표를 제공하고 있다.\n그리고 이 지표는 페이지의 노출, 유저의 이탈률, 나아가 수익성과도 직접적인 연관이 있다.\n\n어찌 보면 당연한 이야기처럼 들릴 수 있다.    \n기사를 작성해 발행하면 포털이나 구글 검색에 *잘 뜨는 것 이 기본이니까*.\n\n![잘..부탁드립니다요](img_1.png)\n\n 아 물론, 내가 기본이라고 말했던 오만함의 **잘** 의 조건은 다음과 같다.\n\n## 🔧 검색 노출을 위한 기술 요소 그리고 해야할 것들\n\n| 항목 | 설명 |\n|------|------|\n| **Core Web Vitals** | 구글이 정한 '웹사이트 건강검진 3종 세트 (LCP, CLS, INP)' |\n| **AMP 지원** | 모바일 최적화를 위한 프레임워크. 초고속 로딩으로 이탈률을 낮춰준다 |\n| **구조화 메타태그** | SNS 공유 시 미리보기 제공 + 검색 결과에 부가 정보 표시 가능 |\n| **반응형 이미지 최적화** | 각 디바이스별로 가장 적절한 해상도의 이미지를 제공 |\n| **코드 스플릿팅** | 페이지별로 필요한 코드만 로딩 → 초기 랜딩 속도 개선 |\n| **경량 이미지** | CDN `w=` 파라미터 조절로 화질은 유지하며 용량은 줄임 |\n| **Lazy Load** | 화면에 들어오기 전까지 이미지/광고 스크립트를 로딩하지 않음 |\n\n\n- 등등 ..\n\n개선해 나아간 부분들이 정말 다행스럽다. 프론트엔드 고수분들을 진심으로 존경하고 존경한다.\n\n---\n## 입사 첫날의 징크스\n\n퇴사후 한달간의 리프레쉬 기간을 갖고, 어찌저찌 현 회사에 투입이 되었다.\n\n구축 외주 인력 분들이 철수하게 되어, 운영에 필요한 인수인계를 받으면 되었다.   \n\n가벼운 마음으로 모닝 커피 마시면서 한분 한분 인사를 드렸다.  \n( 휴식후 너무 오랜만에 사람을 만나서 반가웠고 많이 웃었다.)\n\n그리고 곧 철수하는 분들에게 부럽다는 표정을 숨기고, 잔여 이슈에 대해서 설명하는 시간을 가지기로 하며,\n순조롭게 인수인계를 받을 준비를 하며 노트북을 키는 순간.\n\n그런게 있다. 순조로운 인수인계 + 여유로울 만한 프로젝트 + 이상한 느낌\n\n( 아니겠지 생각이 들때쯤. 부장님 조심 스러우면서 + 다급한 목소리 + 찐 )\n\n**\"형기 씨 . 잠시만, 급한 건인데...\"**\n\n![예 맞아요. 저 오늘 왔어요](img_2.png)\n\n---\n\n## 첫번째 개선 미션\n부장님께서 호출하신 이유는 AMP 페이지가 정상적으로 동작하지 않는 심각한 이슈가 있다고 하셨다.\n\n현재 운영 중인 웹사이트는 Next.js 기반의 웹사이트로, 리뉴얼 개편 이후 트래픽이 1/3 정도 감소했다고 한다.\n\n많은 원인중 제일 큰 이슈는 AMP 페이지가 Google Guide 규칙에 통과되지 못해, 기사의 노출 수 가 줄어들어 트레픽이 하락했다고 한다. \n\n그 결과, **검색 노출 하락 → 사용자 이탈 → 광고 수익 저하** 의 상태.\n\n현재 프로젝트 내에 적용 되어있으나, 동작하지 않는 AMP 페이지를 걷어 낼지, 별도로 다른 프로젝트를 구축하여 AMP 페이지를 만들어서 사용할 수 있는지를 검토 해달라고 하셨다.\n\nAMP 가 뭔지도 모르는 나는 잠깐의 히스토리 설명을 듣고 반나절 정도 분석후 검토할 시간을 달라고 말씀드렸다.\n\n---\n\n## AMP 의 적용 여부 판단\n\n현재 도메인 특성에 맞는 기술인지 판단하고, 개선하면 되는 것을 잘 알기에 조금만 더 digging 을 해보았다. \n( <strike> 구글이 만든 기술이니 구글에 맞는 스킬이겠지. </strike> )\n\n> 📦 AMP 란 ?\n> - AMP 는 Accelerated Mobile Pages의 줄임말로, 모바일 웹 페이지를 더 빠르게 로딩하기 위한 오픈소스 프레임워크 이다.\n> - 구글이 주도해서 만들었고, 현재는 다양한 회사와 커뮤니티가 함께 관리되고 있다.\n> - 빠른 로딩 속도 + 안정적인 사용자 경험으로, 특히 뉴스/블로그/미디어 사이트에 매우 강력한 효과를 준다.\n>\n> 🔐 AMP 는 운영중 제약이 많아 요즘엔 **Core Web Vitals 을 통해 대체하는 추세** 이다.\n\n📉 AMP 단점 요약\n\n| 구분      | 단점 내용                   |\n| ------- |-------------------------|\n| 🧩 기능 | JS 사용 제한, 커스텀 기능 구현 어려움 |\n| 🎨 디자인  | CSS 용량 제한, 커스터마이징 불편    |\n| 🧪 개발 경험 | 디버깅 어려움, validator 의존   |\n| 💼 운영 부담 | AMP 따로 만들고 유지 → 리소스 증가  |\n| 🛰️ 종속성 | 구글 캐시 도메인 문제, 유입 분석 어려움 |\n\n> 제약이 있다는 말은 사용하지 못한다는 것이 아니라, amp 규칙에 맞는 문법으로 대체 해야 한다는 뜻이다.  \n\n예를 들어, js 를 사용하고 싶다면, 아래와 같이 사용해야 한다.\n```html\n<amp-script layout=\"container\" src=\"https://당신의-회사-cdn-주소-혹은-프로젝트-내에-별도-스크립트-파일이-필요합니다-젠장/script.js\">\n  <p>이곳에 스크립트가 삽입됨.</p>\n</amp-script>\n```\n\n⚡ AMP 장점 요약   \n\n| 구분                 | 장점 내용                                               |\n| ------------------ | --------------------------------------------------- |\n| 🚀 속도              | AMP는 로딩 속도가 **압도적으로 빠름** (HTML + 제한된 JS/CSS만 허용)    |\n| 📱 사용자 경험          | 기본적으로 Lazy Load + Viewport 우선 렌더링 → **UX 최적화**      |\n| 🔍 검색 최적화          | **구글 AMP 캐시**에 의해 빠른 응답 + 검색 상단 노출 가능성 증가           |\n| 💎 Core Web Vitals | LCP, CLS, INP 등 **성능 지표 자동 개선 효과**                  |\n| 📈 SEO/트래픽         | 빠른 로딩 + UX 개선 → **이탈률 감소 + 유입 증가**                  |\n| 🧰 내장 컴포넌트         | `amp-img`, `amp-carousel` 등으로 **인터랙션을 JS 없이 구현 가능** |\n| 🧵 일관성             | AMP validator 통과 필수 → **표준화된 코드와 구조 강제**로 QA 부담 감소  |\n\n\n🤔 현재 도메인에 AMP 적합성 요약  \n\n현재 운영 중인 웹사이트는 기사 본문 중심의 뉴스 사이트다. 즉, 동적인 UI보다는 텍스트 콘텐츠 위주로 구성되어 있다.  \n\n사용자가 본문을 한 번 로드한 이후에는 인터랙션이 거의 없는 만큼 사용자 경험이 단순하고, 정적 콘텐츠 중심인 구조다.  \n\n이런 특성의 사이트는 AMP의 제약과 잘 맞는다.\n복잡한 JS 상호작용이 거의 없고 페이지의 빠른 로딩과 안정적인 레이아웃이 더 중요하기 때문이다.\n\n\n| 유형                   | AMP 적합도 | 이유                                       |\n| -------------------- | ------- | ---------------------------------------- |\n| 📰 뉴스, 미디어, 퍼블리싱 플랫폼 | ✅ 매우 적합 | 정적 콘텐츠 중심 + 검색 유입이 중요                    |\n| 🛍️ 쇼핑몰, 커뮤니티, SaaS  | ⚠️ 부적합  | 동적 UI, 사용자 상호작용 많음                       |\n| 📅 2024 이후           | 선택적 적용  | 구글이 AMP 강제 ↓, 다만 여전히 Top Stories 노출은 유리함 |\n\n---\n\n## 검색 유입의 트랜드\n🥰 국내 뉴스 유입이 포털 중심에서 검색 중심으로 넘어오고 있다는 사실.\n\n물론 한국은 네이버·다음 같은 **포털 중심의 뉴스 소비 성향**이 강하다.  \n하지만 최근에는 **구글 검색 + 유튜브 검색을 통한 뉴스 소비도 꾸준히 증가 중**이다.\n\n> 특히 검색 기반 유입은 ‘롱테일 콘텐츠’ 확보에 핵심.  \n> 반면, 포털 메인은 *경쟁도 심하고, 노출 타이밍도 예측이 불가능*\n\n오케이 🙆 도메인 적합성 + amp 배경지식 습득 완료 . 그럼 이제 트러블 슈팅 을 해보자.\n\n![이 요망한 걸림돌들](img_4.png)\n\n앞서 말했듯이 **AMP 페이지 는 정적 검증기 인 AMP Validator 를 통과해야만 페이지가 동작 가능** 하다. \n\n구글 search console 에서 계속 안되는 이유를 친절하게 알려준다.   \n본문에 허용하지 않는 Tag 가 선언되어 있거나, ./next/static 하위 js 번들이 html 전체 문서에 포함되어 있으면 AMP 페이지가 정상적으로 동작하지 않는다고. ( 훌륭해.. )\n\n그러나, 문제의 *태그* 를 해결해도 왜 next 번들 파일이 guide 규칙에 걸리는지 의문을 품던 도중\n\n![앱 라우터에서 AMP 지원이 제거되었습니다.](img_3.png)\n![현재 App Router에서 AMP 지원은 계획되어 있지 않습니다.](img_6.png)\n![AMP는 App Router에서 지원되지 않습니다.](img_7.png)\n![공식문서 - Pages Router 탭 에서만 AMP 가 존재](img_8.png)\n\n<h3>프로젝트 내에 AMP Page 가 App Router 기반으로 구현되어 있었고 이로인해 못쓴다는 뜻.</h3>\n- 다 걷어내야 됌\n\n![거짓말](img_9.png)\n\nNext.js의 pages 라우터 기반에서만 정식 지원하고, app router 기반에서는 공식적으로 AMP 지원이 되지 않는다는 사실을 알았다.\n\n아래와 같은 구조에서 pages 하위에만 Amp 대상 페이지를 두면 되긴 하는데..    \n문제는 현재 *app 디렉토리에 AMP 페이지가 개발되어 있는상태.* ( 범인 색출 성공 )   \n\n![pages 는 구식 app 은 신식](img_5.png)\n \n마치 판매 기준을 어긴 것 과 같다. 샌드위치 속 재료를 기준에 맞게 모두 바꿨지만, 포장지가 비닐이 아니라 종이여야 했던 걸 몰랐던 상황처럼.\n\n천만 다행으로, app / pages 라우터 방식을 next 에선 **모두 지원** 하니 모두 pages 방식으로 forting 하는 불상사는 발생하지 않는다. \n\n실험적으로 pages router 방식으로 mock 으로 테스트해보니, AMP Validator 에 걸리지 않은것도 확인 ✅\n\n다시 부장님께 Amp 대상 페이지가 어떤것인지 여쭤보았고, **기사 상세 페이지만 대상** 이라고 하셨다. \n\n---\n\n## 결론\n- ✅ AMP 에 대한 배경지식 체크\n- ✅ 현재 도메인에 AMP 적용은 적합\n- ✅ AMP 페이지는 pages router 방식에서만 지원\n- ✅ 모든 페이지를 Pages router 방식으로 전환 하는게 아니라 기사 상세 페이지만 AMP 페이지로 별도 구성\n\n> 모든걸 옮길 필요 없이 뉴스 본문 기사만 옮기면 된다. ( 나머지 페이지는 app router 구조에서 계속 사용 가능. )\n\n## 🏗️ AMP 페이지 개발\n다음 편에서 계속.\n\n## 참고 자료\n- [Next.js AMP 공식 문서](https://nextjs.org/docs/app/building-your-application/routing/pages-and-layouts#amp)\n- 시간을 아껴주신 분들\n  - [버셀에 문의까지 주신분](https://www.reddit.com/r/nextjs/comments/1dpuvj7/how_do_i_configure_a_page_to_be_amp_in_app_router/)\n  - [그외-외국 형님1](https://github.com/vercel/next.js/discussions/76918)\n  - [그외-외국 형님2](https://github.com/vercel/next.js/issues/64354)\n"},{"excerpt":"Rag (Retrieval Augmented Generation) 의 탄생 배경 RAG 은 대규모 언어 모델(LLM)의 한계를 극복하기 위해 개발된 기술로, 검색과 생성의 결합을 통해, 작업에서 정확하고 맥락에 맞는 답변을 생성하거나. 최신 정보와 특정 도메인 데이터를 동적으로 활용할 수 있도록 설계된 기술이다. LLM 은 어떤 한계를 가졌을까 ? LLM…","fields":{"slug":"/rag/"},"frontmatter":{"date":"March 29, 2025","title":"Rag","tags":["AI"]},"rawMarkdownBody":"\n## Rag (Retrieval Augmented Generation) 의 탄생 배경\n**RAG** 은 대규모 언어 모델(LLM)의 한계를 극복하기 위해 개발된 기술로, 검색과 생성의 결합을 통해, 작업에서 정확하고 맥락에 맞는 답변을 생성하거나. 최신 정보와 특정 도메인 데이터를 동적으로 활용할 수 있도록 설계된 기술이다.\n\n## LLM 은 어떤 한계를 가졌을까 ?\nLLM 의 한계는 학습 데이터를 기반으로 응답을 생성하다 보니, 새로운 정보나 특정 도메인 지식에 대한 질문에 대한 질의 응답을 할수가 없었다. 만약 한다 하더라도 AI 헛소리 라고 불리우는 **할루시네이션** 문제가 발생하였다. 즉, **거짓말** 이다.\n\n## RAG 의 탄생 배경\n2020년 9월 28일 Meta AI 연구진이 발표한 논문 *\"Retrieval-Augmented Generation for Knowledge-Intensive NLP Tasks\"*를 통해 처음 소개되었다. <br/> \n이 연구는 Facebook AI Research(현재 Meta AI), University College London, 그리고 New York University의 협력으로 이루어졌다. <br/> \n주요 저자는 Patrick Lewis를 포함한 여러 연구진으로, 이들은 기존 LLM이 가진 정적 데이터 의존성과 할루시네이션(hallucination) 문제를 해결하기 위해 RAG를 개발했다. <br/>\n외부 데이터베이스나 문서 저장소 등에서 관련 정보를 검색하고 이를 기반으로 응답을 생성하는 구조를 채택했다.\n\n## RAG의 작동 방식\n- 검색(retrieval): 사용자가 입력한 질문에 따라 관련된 지식을 외부 데이터베이스나 문서에서 검색한다.\n- 생성(generation): 검색된 정보를 **통합**하여 **적절한 텍스트**로 생성한다. ( 맥락에 맞는 답변 )\n- 증강(augmentation): 검색된 데이터를 LLM의 입력 프롬프트에 추가하여 응답의 품질을 높인다.\n\n## RAG의 주요 특징\n- **동적 정보 활용**: 정적 학습 데이터에 의존하지 않고 최신 정보를 반영할 수 있다.\n- **효율성**: 모델 전체를 재학습하지 않아도 외부 데이터베이스만 업데이트하면 된다.\n- **신뢰도 향상**: 검색된 데이터를 기반으로 응답을 생성해 할루시네이션 문제를 완화한다.\n\n\"검색(retrieval)\"과 \"생성(generation)\"을 결합한 구조를 도입 함으로써, 사용자의 입력에 따라 외부 지식 베이스(예: 데이터베이스, 문서 저장소)에서 관련 정보를 검색하고, 이를 기반으로 더욱 정확하고 맥락에 맞는 응답을 생성하게 되었다.\nRAG는 정적 데이터에 의존하지 않고 동적으로 정보를 활용할 수 있는 능력을 갖추게 된다."},{"excerpt":"아이스 브레이킹 22 년 어느날, Back-end 개발자로 개발생활을 영위하며 바쁜 일상생활을 보내고 있었던 🍁가을무렵 이였다. 헤성처럼 나타나 개발자들에게 \"코더 계속 하실 ?\" 이라는 극딜을 준 G 선생. 솔직히 처음 모델만 해도 리펙토링 정도만 살짝 참고하는 정도여서 전혀 히지 않았다. 분명 그랬을 터인데, 24년 여름쯤 이였다. 일정 테트리스로 인…","fields":{"slug":"/spring-ai/"},"frontmatter":{"date":"March 29, 2025","title":"Ai. Spring AI 로 때워도 되나유? 1편","tags":["AI","Spring"]},"rawMarkdownBody":"\n## 아이스 브레이킹\n\n22 년 어느날, Back-end 개발자로 개발생활을 영위하며 바쁜 일상생활을 보내고 있었던 🍁가을무렵 이였다. 헤성처럼 나타나 개발자들에게 *\"코더 계속 하실 ?\"* 이라는 극딜을 준 G 선생. 솔직히 처음 모델만 해도 리펙토링 정도만 살짝 참고하는 정도여서 전혀 `긁`히지 않았다. 분명 그랬을 터인데, 24년 여름쯤 이였다. 일정 테트리스로 인하여 여러 프로젝트가 겹쳐 시간이 빠듯하였고 결국 생성형 AI 를 적극 활용하기로 하였다. 그 결과 무려 10배 혹은 20배나 되는 `생산성의 맛` 을 봐 버렸고. 요망한 AI 에게 의존하는 삶을 살게 되었다.\n![ㅎ...형!!!](image-2.png)\n\n의존 하다보니 느끼는 감정은 날것 그대로 쓰기엔 오류도 많고 아직 사람손이 타야하는 영역이 많긴한데, 점점 그 빈도가 **줄어들고 있다는 점**에서 불안과 걱정의 씨앗이 심어졌다. 정말 어느 순간 모르게 급격하게 발전해서 **\"비즈니스 영역까지 커버하게 된다면\"** 더이상 내 자신이 회사에 필요하지 않게될 날이 도래하겠다는 생각이 들었다. \"에이 ~ AI 는 아직 부족한 부분이 많으니 대체되지 않을거야\" 라는 **미련을 빨리 버려야 된다**고 생각했다. 그러나 처음부터 AI 의 모든 영역을 공부하기엔 현실적으로 많은 러닝커브가 따르고 막막하여 생각에 잠긴다.\n\n> 1️⃣ Web 개발자 관점에서 AI 를 활용하기 위해 어떤 개념들을 알아야 할까 🤔 ? <br/>\n> 2️⃣ Spring AI 가 있다는데, python 없이도 AI 기술들을 커버할 수 있는걸까 🤔 ? <br/>\n> 3️⃣ 많이 뒤쳐진것 같아 불안해. 빠르게 AI 기술들을 적용해보고 싶어 ‼️ <br/>\n\n## 돈워리. Web 개발자 관점에서 요구되는 AI 기술 부터\n웹 개발자는 AI 모델을 직접 연구하거나 신경망을 설계하는 사람이 아니다. **AI를 활용하여 제품을 개발하고 사용자 경험을 향상시키는 데 초점**을 맞추어야 한다. 단, 요구되는 지식은 다음과 같다.\n\n- **AI 기술 이해**: ( 머신러닝 딥러닝 기본 개념 ), AI 모델 작동 방식\n- **API 및 라이브러리 활용**: openAi API 과 같은 도구를 사용하여 애플리케이션에 AI 기능 통합\n- **멀티모달 데이터 처리**: 텍스트, 이미지, 음성 등 다양한 데이터를 처리하여 사용자 경험 개선\n- **데이터 기반 의사결정**: 사용자 데이터를 분석하고 이를 기반으로 제품 설계 및 최적화.\n\n> 기술의 발전과 패러다임을 보면 항상 사용자에게 시간을 준다. 딱 5년. 2년도 안남았네 .. <br/>\n> 🏃🏿 지금부터 SpringAI 를 기점으로 AI 와 빠르게 친해지는 길로 달려보는 수 밖에.\n\n\n## Spring AI란 무엇인가?\n\n![출처 - https://spring.io/projects/spring-ai](image-3.png)\nSpring AI는 Java 개발자를 위한 AI 통합 프레임워크다. 기존에 AI 기능을 추가하려면 Python, 머신 러닝, 딥 러닝에 대한 광범위한 지식이 필요했는데 Spring AI를 사용하면 개발자가 OpenAI의 GPT-4 및 DALL-E 3의 기능을 쉽 게 활용할 수 있어, Java 개발자가 복잡한 인공 지능 기능에 액세스 할 수 있게 되었다. Spring 기술과 자연스럽게 연결되기 때문에 AI 기술을 `처음부터` 배우지 않아도 된다.\n\n## 왜 Spring AI로 시작해야 할까?\n\nSpring AI는 복잡한 AI 기술을 Java 개발자가 쉽게 접근할 수 있도록 단순화 되어있다. 굳이 채택하려는 이유라고 하면 다음과 같다.\n- **효율성**: 기존 Spring 생태계를 활용해 빠르게 시작 가능.\n- **확장성**: 다양한 모델과 데이터베이스를 유연하게 교체 및 확장 가능.\n- **생산성 향상**: 반복 작업을 자동화하고, 개발자가 중요한 문제 해결에 집중할 수 있도록 도움.\n\n## Spring AI로 무엇을 만들 수 있을까?\n\nSpring AI를 활용하면 다음과 같은 애플리케이션을 개발할 수 있다.\n- RAG 기반 검색 시스템: 질문에 대해 정확한 답변을 제공하는 검색 엔진.\n- 대화형 챗봇: OpenAI GPT-4와 연동된 스마트 대화 시스템.\n- 이미지 분석 및 생성: 멀티모달 기능을 활용한 이미지 처리 애플리케이션.\n\n> Toy Project 딱대 🥰  마지막으로 Spring AI 의 주요 기능과 설명으로 이번 포스팅을 마치며, <br/> 대화형 chat api 를 open ai 를 활용하여 toy project 를 다루는 방향으로 2 편을 작성해보려고 한다.\n\n## 주요 기능 과 설명\n| 기능                              | 설명                                                                 | 장점                                                                                       |\n|--------------------------------------|-----------------------------------------------------------------------------|--------------------------------------------------------------------------------------------------|\n| Boot Auto Configuration Support      | Spring Boot와의 통합으로 AI 기능을 쉽게 설정할 수 있다.                     | 복잡한 설정 코드를 줄여 개발 속도를 높인다.                                                            |\n| Multiple AI Support                  | OpenAI, Hugging Face, Google BERT 등 여러 AI 모델을 쉽게 사용할 수 있다.    | 다양한 AI 모델 간의 비교와 최적화를 쉽게 수행할 수 있으며, 모델 변경 시 코드 수정이 최소화된다.                        |\n| ChatClient API                       | AI와 대화하는 기능을 쉽게 구현할 수 있다.                                  | 대화형 AI 애플리케이션을 쉽게 구축할 수 있으며, 사용자와의 상호작용을 원활하게 처리한다.                             |\n| Prompt Template                      | 프롬프트 템플릿을 통해 AI에 보낼 입력값을 쉽게 조정할 수 있다.               | 코드의 재사용성을 높이고, 다양한 요구 사항에 맞는 질의를 손쉽게 작성할 수 있다.                                    |\n| Vector Embedding and Search          | 문서를 벡터화하고, 벡터 검색을 통해 고성능 검색 엔진을 구현할 수 있다.       | 복잡한 데이터를 효율적으로 검색하고 분석할 수 있으며, 이는 정보 검색 및 추천 시스템에 유용하다.                        |\n| Advisors API                         | 반복적인 생성 AI 패턴을 캡슐화하고, 데이터를 변환하여 다양한 모델과 사용 사례에 걸쳐 이식성을 제공한다. | AI 애플리케이션의 구조적 설계를 간소화하고, 성능을 최적화하며, 변화하는 요구사항에 빠르게 적응할 수 있다.              |\n| Retrieval Augmented Generation (RAG) | 정보 검색과 생성 AI를 결합하여 더 정확하고 신뢰할 수 있는 콘텐츠를 생성하는 기술을 지원한다. | 대규모 언어 모델의 한계를 보완하여 질문에 대한 더 정확한 답변을 제공한다.                                        |\n| Observability and Model Evaluation   | AI 관련 작업에 대한 통찰력을 제공하고, 생성된 콘텐츠의 품질을 평가하는 도구를 지원한다. | AI 모델의 성능을 모니터링하고, 잘못된 응답을 방지하여 시스템의 신뢰성을 높인다.                                        |\n\n---\n"},{"excerpt":"Redis 를 활용한 분산 lock","fields":{"slug":"/basic/"},"frontmatter":{"date":"April 02, 2024","title":"Redis","tags":["Redis"]},"rawMarkdownBody":"\n## Redis 를 활용한 분산 lock\n\n"},{"excerpt":"코루틴(Coroutine) co-routine: 말 그대로, 협력하는 루틴 이라는 뜻이다. 👩🏻‍💻 루틴 우리는 일반적인 루틴을 이해하고 있다. 아침에 일어나서 세수하고, 밥먹고, 출근하고, 일하고, 퇴근하고, 저녁먹고, 잠자고...   직장인의 루틴이다.  (돈많은 백수 이고 싶어..)     코드의 실행 흐름을 보면 뭔가 루틴이라고 할 수 있다.     코…","fields":{"slug":"/coroutine/"},"frontmatter":{"date":"February 12, 2024","title":"코 루틴","tags":["kotlin"]},"rawMarkdownBody":"\n## 코루틴(Coroutine)\nco-routine: 말 그대로, 협력하는 루틴 이라는 뜻이다.\n\n## 👩🏻‍💻 루틴\n\n우리는 일반적인 루틴을 이해하고 있다.  \n아침에 일어나서 세수하고, 밥먹고, 출근하고, 일하고, 퇴근하고, 저녁먹고, 잠자고...  \n\n직장인의 루틴이다.  (돈많은 백수 이고 싶어..)    \n\n코드의 실행 흐름을 보면 뭔가 루틴이라고 할 수 있다.    \n```kotlin\n\nfun main() {\n\n    println(\"wake up\")\n\n    goToCompany()\n\n    println(\"sleep\")\n}\n\nfun goToCompany() {\n    val num1 = 1\n    val num2 = 2\n    println(\"오늘도 커피 ${num1 + num2} 잔 ...\")\n}\n\n```\n\n코드의 실행 관점을 보면 다음과 같다.\n- wake up\n- goToCompany() 함수 호출 후 오늘도 커피 3 잔 ... 을 출력\n- sleep\n\n> 흐름이 매우 훌륭하게 직관적인 것을 볼 수 있다.\n\n![너무 당연한게 맞다.](img.png)\n\n그리고 메모리 관점으로 보면 다음과 같다. \n- main 함수 내에 wake up 출력\n- goToCompany 이라는 함수가 호출\n  - num1, num2 의 지역변수가 초기화된 이후 오늘도 커피 3잔 이 출력\n- main 함수로 돌아와서 sleep 출력\n- goToCompany 이 끝나면 해당 메모리에 접근이 불가 ! \n\n> 그리고 언젠간 GC 에 의해서 언젠가 메모리도 사라질 것이다.  \n> 루틴에 진입하는 곳이 한군데 이며, 종료되면 해당 루틴의 정보가 초기화 된다.    \n> 그런데 코루틴의 흐름은 다르다.\n\n```kotlin\nimport kotlinx.coroutines.launch\nimport kotlinx.coroutines.runBlocking\nimport kotlinx.coroutines.yield\n\nfun main(): Unit = runBlocking { // 👉 main 코루틴 생성 ( runBlocking )\n\n    printWithThread(\"wake up\")   // (1️⃣)\n \n    launch {                     // (2️⃣) 새로운 코루틴 생성\n        goToCompany()\n    }\n\n    yield()                      // (3️⃣) main 코루틴 중단 → 다른 코루틴에게 기회\n    \n    printWithThread(\"sleep\")     // (6️⃣) 재개 후 실행\n}\n\nsuspend fun goToCompany() {\n    val num1 = 1                 // (4️⃣) 지역변수 초기화\n    val num2 = 2                 \n\n    yield()                      // (5️⃣) 코루틴 중단\n    \n    printWithThread(\"오늘도 커피 ${num1 + num2} 잔 ...\")\n}\n\nfun printWithThread(message: String) {\n    println(\"${Thread.currentThread().name} : $message\") // (7️⃣) \n}\n\n```\n\n> 일반 함수처럼 코드 흐름을 글로 적으면 혼란만 가중된다.  \n> 표로 보는게 제일 이해가 빠르다.\n\n## 코루틴의 흐름\n\n| 시점 | 실행 위치 | 메모리 상태 (코루틴, 변수 등) |\n|------|-----------|------------------------------|\n| (1)  | `wake up` 출력 | `main()` 스택에 문자열 리터럴만 존재 |\n| (2)  | `launch` 코루틴 생성 | `goToCompany()` 코루틴 생성됨 (스케줄링됨), 별도 스택 생김 |\n| (3)  | `yield()` in main |  main 코루틴이 중단(suspend) 되고, CoroutineScheduler가 다른 코루틴(launch)을 실행할 수 있는 기회를 얻음 |\n| (4)  | `goToCompany()` 진입 | `num1 = 1`, `num2 = 2` 지역 변수 생성 및 값 저장 |\n| (5)  | `yield()` in goToCompany | 해당 코루틴이 suspend됨, 지역 변수 상태는 유지됨 |\n| (6)  | `main()` 재개 → `sleep` 출력 | main 코루틴이 재개되며 `\"sleep\"` 출력 후 종료로 향함 |\n| (7)  | `goToCompany()` 재개 | `\"오늘도 커피 3 잔...\"` 출력 후 종료 |\n| (끝) | 모든 코루틴 종료 | 스택 해제 및 모든 지역 변수 메모리 해제 대기 |\n\n## 메모리 상태\n| 시점  | 코루틴            | 지역 변수 (`num1`, `num2`)    | 상태              |\n|-----| -------------- | ------------------------- | --------------- |\n| (1) | main           | —                         | 실행 중            |\n| (2) | launch 생성됨     | —                         | 대기 중            |\n| (3) | main 중단        | —                         | 일시 정지           |\n| (4) | goToCompany 실행 | `num1 = 1`, `num2 = 2`    | 실행 중            |\n| (5) | goToCompany 중단 | `num1 = 1`, `num2 = 2` 유지 | 상태 저장 (Suspend) |\n| (6) | main 재개        | —                         | 마무리             |\n| (7) | goToCompany 재개 | 기존 상태 복원됨                 | 결과 출력 후 종료      |\n\n\n> 🧠 코루틴은 일반 함수처럼 메모리가 “한 번에 초기화되고 버려지는” 구조가 아니다.  \n> 대신 중단(suspend) 되었다가 재개(resume) 가능한 스택을 가지며, 메모리도 해당 지점까지의 상태를 \"기억하고 유지\" 한다.\n\n💡 핵심 요약\n- runBlocking은 메인 쓰레드에서 블로킹되며 CoroutineScope을 제공함\n- launch는 별도 코루틴 생성, 독립적인 메모리(스택 프레임) 가 생김\n- yield()는 현재 코루틴을 중단(suspend) 상태로 만들고 CoroutineScheduler가 다른 코루틴을 실행할 수 있도록 기회를 줌 \n- suspend fun은 중단 가능한 함수이며, 중단 지점 이후 상태를 기억하고 재개 가능 \n- 중단된 지점의 지역 변수 상태는 메모리상에 보존됨 (heap이나 continuation에 저장됨)\n\n## 일반 함수와 코루틴의 메모리 관점 차이\n![실행 흐름](img_1.png)\n\n\n---\n"},{"excerpt":"문득 java 21 이 등장하면서 virtual Thread 가 hot 한 지금..  한물 간다는 webFlux 를 공부하는게 맞을까 ...? 아니다... 왜 사라지는지 확실하게 짚고 넘어가는 게 맞다... cpu Bound 와 IO Bound 에 대해서 알아보자 단순 cpu 를 쓴다 라고 끝나는게 아니라, 다수의 데이터에 대한 집계 혹은 암호화 등 cp…","fields":{"slug":"/cpu-bound-vs-io-bound/"},"frontmatter":{"date":"January 12, 2024","title":"CPU Bound 와 IO Bound","tags":["webFlux"]},"rawMarkdownBody":"\n# 문득 java 21 이 등장하면서 virtual Thread 가 hot 한 지금..\n![img.png](img.png)\n### 한물 간다는 webFlux 를 공부하는게 맞을까 ...?\n> 아니다... 왜 사라지는지 확실하게 짚고 넘어가는 게 맞다...\n\n### cpu Bound 와 IO Bound 에 대해서 알아보자\n- 단순 cpu 를 쓴다 라고 끝나는게 아니라, 다수의 데이터에 대한 집계 혹은 암호화 등 cpu 계산 능력에 따라 성능이 좌지우지 되는 능력을 말한다.\n\n### 아래 그림을 보자\n![img_1.png](img_1.png)\n\n위 그림을 보면 `application 영역`, `커널 영역`, `하드웨어 영역` 을 계층화 하여 추상화로 나타낸 그림이다. <br/> \n여기서 동시간에 하나의 명령어를 처리할 수 있는 CPU core 가 한개 있다고 가정해보자 <br/>\n\napplication 은 실행되는 프로세스라고 보면 된다. <br/>\n이때 물리적인 cpu core 에 명령을 내린다고 가정해보자 <br/>\n\n![img_2.png](img_2.png)\n\n그리고 어플리케이션이 N 개가 더 추가되어 단일 CPU 코어 1 에 각각의 작업을 동작시켰다고 가정해보자. <br/>\n\n![img_3.png](img_3.png)\n\n이떄 CPU 코어에서는 동시에 실행한 것처럼 보일수 있다 <br/>\n\n> 그럼 동시에 `병렬` 로 처리한걸까 ? \n\n![img_4.png](img_4.png)\n\n그렇지 않다. 동시간대 하나의 명령만 처리 할 수 있기 때문에, 타임 슬라이스를 아주 잘게 나눠서 잘라보면 <br/>\n실제로 어플리케이션 1 번과 2 ... N 번이 번갈아 가면서 실행하게 된다. <br/>\n\n이렇게 번갈아 가면서 실행하는 과정을 OS 에서는 Context Switching 이라고 한다.\n> 실행관점에서 문맥을 바꾸었다. 라는 의미다.\n\n이러한 컨텍스트 스위칭 (ContextSwitching) 작업들은 CPU Bound 어플리케이션 에서 성능 저하를 가져오게 되는데 <br/>\n\n그림으로 보면 아래와 같다.\n\n![img_5.png](img_5.png)\n\n어플리케이션이 실행되어 메모리에 로드되고 프로세스로 동작하게 될텐데. <br/>\nCPU 로 스케줄링 되어 실행될때, 기계어 실행을 위해 필요한 데이터들을 cpu Register 로 미리 가져오게 된다. <br/>\n\n그리고 ALU 를 통해 실제 계산을 진행하게 되는데 Register 에는 기존에 어떤 명령까지 진행했는지를 함께 저장 해 놓고 <br/>\n필요에 의해 캐시를 해놓기 때문에, 동일한 프로세스의 일을 꾸준히 하면 할 수록 성능적으로 더 효과 적이다.\n\n![img_6.png](img_6.png)\n\n컨텍스트 스위칭은 위 그림과 같이 어플리케이션 2번을 실행시키기 위해 Register 정보를 초기화 하는 과정부터 시작한다. <br/>\n정확히는 어플리케이션 1 번이 실행했던 기존 실행 정보들을 메모리에 별도 저장 해 놓고, 2 번 어플리케이션 데이터 정보를 가져와서 다시 Register 적재를 한 뒤 명령어들을 실행하게 된다. <br/>\n하나의 CPU 에서 다수의 프로세스들이 번갈아 가면서 cpu 작업들을 진행해야 하기 때문에 성능상 오버헤드가 발생한다고 할 수 있다. <br/>\n\n### 그럼 여기서 문제...\n![img_7.png](img_7.png)\n\n위 어플리케이션 들을 어떻게 실행시키는게 가장 빠를까 \n> 하나씩 순차적으로 실행하는게 가장 빠르다 ( 너무 당연한가 ? ) <br/>\n> 컨텍스트 스위칭 이라는 오버헤드가 있기 때문 <br/>\n\n### 어떻게 하면 CPU Bound 상황을 효과적으로 만질 수 있을까 ?\n![img_8.png](img_8.png)\n\n흔히 말할 수 있는 정략은 위와 같이 병렬 처리 되어야 효과적이다. <br/>\n동 시간대 각각의 명령어를 동 시간대에 처리할 수 있기 때문이다. <br/>\n\n## I/O Bound 란\n입출력 장치의 중점적인 작업들을 말한다. <br/>\n대표적인 작업들은 키보드와 같은 사용자 입력, 디스크 파일 복사, 네트워크를 통한 데이터를 주고받는 행위들을 모두 I/O 작업이라고 한다.\n![img_9.png](img_9.png)\n\n위 그림과 같이 client 와 server 는 연결이 되어있는 상태이고, Hello 라는 문자열을 네트워크를 통해 전송한다고 가정해보자. <br/>\n\n![img_10.png](img_10.png)\n\nNIC ( Network Interface Card ) 장치 는 네트워크 패킷을 주고 받는 역할을 맡고 있다. <br/>\nClient 가 전달한 Hello 패킷을 Nic 장치를 통해 전달받고, 커널에서 네트워크 프로토콜을 진행하게 되는데 <br/> \n서버 application 입장에선, Kerner 에서 패킷을 전달받기 전까지 ```대기``` 를 하게 된다. <br/>\nNic 장치 로 부터 패킷을 받고 커널 까지의 과정 또한 CPU 사용이 필요한 영역이긴 한데, <br/>\napplication 관점에서는 패킷을 수신 완료까지 를 대기하기 때문에, CPU 를 중점적으로 사용하지 않는 상태라고 볼 수 있다. <br/>\n만약 패킷이 오지 않았다 라고 가정한다면, 해당 서버의 프로세스는 계속해서 대기를 하게 되는것이다. <br/>\n\n## Web Application 서버 관점에서 어떠한 I/O 들이 있을까\n![img_11.png](img_11.png)\n\n그림으로 보면 클라이언트로 부터 전달 받는 http 프로토콜을 처리하는것도 web Application 에서는 network I/O 이고, <br/> \nWeb Application 에서 비즈니스 로직 이후 DB 에 쿼리하는 영역도 I/O 이다. <br/>\n또한 DB 시스템에서 데이터를 조회하고, 삭제하고, 저장하는것도 I/O 라고 볼 수 있고, <br/>\nWeb Application 에서 외부 API 서버 요청 에 대한 것도 네트워크 I/O 가 발생하게 된다 <br/>\n\n> 하나의 웹 서비스 에서도 I/O 작업이 여기저기 산재되어 있는데, 반드시 인지하고 있어야 할 개념이다.\n\n## 만약 클라이언트로 부터 많은 요청이 들어오게 된다면, 어떻게 해야할까\n전통적인 해결 방법은 webApplication Thread 갯수를 늘리는 것이다.\n![img_13.png](img_13.png)\n\nThread Per Request 혹은 Thread for Connection 이러고도 하는데, 이는 <br/>\n하나의 요청에 하나의 Thread 가 필요하다는 의미이다. <br/>\n\n예를들어 굉장히 많은 Thread 가 실행된다고 가정한다면, <br/>\n성능 관점에서 CPU 컨텍스트 스위칭을 고려해야 하는데, 이런 컨텍스트 스위칭 오버헤드를 감수하더라도 I/O 요청을 최대한 처리할 수 있도록 하는 전략이라고 볼 수 있다. <br/>\n\n만약에 하나에 Thread 가 하나의 연결을 처리하고 있는 순간 다른 추가 요청이 있게 되면, <br/>\n대기를 하는게 아니라 또다른 Thread 를 처리하게 된다. <br/>\n\n만약 대량의 요청을 처리하기 위해 요청 수 만큼 Thread 갯수를 늘리게 되면 결국 OOM 이 나버리게 된다.<br/>\n만약 10만의 요청을 동시처리하고 싶다고 가정한다면, `(10 만 * 스레드 크기 )` == `메모리 용량` 이 되버린다.<br/>\n거기에 하드웨어 최대 메모리까지 사용하게 되면 시스템이 아예 동작하지 못할수도 있다.<br/>\n\n커널에는 OOM 이라는 안전장치가 존재한다. ( 주요 프로세스를 Kill 해서 시스템 다운을 예방하는 역할 )<br/>\n\n반면 사용이 완료된 Thread 를 삭제하는것도 문제다. <br/>\n새로 들어오는 요청에 의해 다시 만들어야 되니까 ..<br/>\n결국 쓰레드를 관리해야 하는것이 성능 관점에서 손해이다. <br/>\n\n이떄문에 Thread Pool 이 해결 방안으로 볼 수 있겠다. <br/>\n\n> 가용 가능한 다수의 쓰레드를 미리 만들어 놓고, <br/>\n> 요청이 들어오면 미리 만들어 놓은 쓰레드를 활용하고 사용이 다 했으면 해당 쓰레드를 다시 쓰레드 풀 에 반납하는 전략을 말한다. <br/>\n\n\n\n"},{"excerpt":"코들린의 현재와 미래 코틀린을 배워야하는 이유 코틀린은 IntelliJ로 유명한 젯브레인사에서 만든 언어이기 때문에 IntelliJ에서 자동완성, 자 바-코틀린 변환, 코루틴 등 코틀린 관련 편의 기능을 완벽하게 지원 자바는 발표된지 20년이 넘었지만 코틀린, C#, 스위프트와 같은 현대적 언어에 비해 기능 이 부족함 자바에서 Best-Practice로 …","fields":{"slug":"/basic/"},"frontmatter":{"date":"January 12, 2024","title":"코틀린의 현재와 미래","tags":["코틀린"]},"rawMarkdownBody":"\n# 코들린의 현재와 미래\n### 코틀린을 배워야하는 이유\n- 코틀린은 IntelliJ로 유명한 젯브레인사에서 만든 언어이기 때문에 IntelliJ에서 자동완성, 자 바-코틀린 변환, 코루틴 등 코틀린 관련 편의 기능을 완벽하게 지원\n- 자바는 발표된지 20년이 넘었지만 코틀린, C#, 스위프트와 같은 현대적 언어에 비해 기능 이 부족함\n- 자바에서 Best-Practice로 불리는 기법들을 언어적 차원에서 기본 제공\n- 자바에 비해 문법이 간결하기 때문에 가독성과 생산성이 높고 오류 가능성이 적어진다\n\n```kotlin\ndata class Person(\n        val name: String, \n        val age: Int, \n        val email: String\n) // equals(), hashCode(), toString() 등 유용한 함수를 자동 생성\n\nobject MyCompany { // 싱글턴 객체 \n    const val name: String = \"MyCompany\"\n}\n\n// 탑- 레벨 함수로 클래스 외부에서 함수 작성 가능\nfun main() {\n    // `new` 키워드 없이 객체 생성\n    val person = Person(\"이상훈 \", 35, \" digimon1740 @gmail.com \")\n}\n```\n\n### 좀더 파해쳐 보자\n- 문법 간결\n- data class 라는 기능을 사용하게 되면\n  - 자동으로 equals, hashcode, toString 을 자동으로 생성함\n- object 라는 키워드를 사용하게되면\n  - 간단하게 싱글턴 객체를 만들어준다.\n- 함수를 탑 레벨에 위치\n  - 탑 레벨 함수는 클래스 외부에서 함수를 작성할 수 있는 기능이다. ( 별도의 클래스 없이 작성가능 )\n  - 반면 자바에서는 기본적으로 클래스를 만들고 그 안에서 메서드를 만든다.\n- new 키워드 없이 객체를 만들 수 있다.\n- 멀티 플랫폼 언어이다\n  - 서버개발\n  - e.g ) 모바일 앱, 프론트 js, 안드로이드\n\n### 기업의 개선점\n- google 의 경우 npe 를 33% 절감 함\n- 그로인해 사용자 환경은 크게 향상 시켰다.\n\n### 코틀린 타임라인\n- 2016년 2월 코틀린 1.0 릴리즈\n- 2017년 1월 스프링 프레임워크 5.0 부터 코틀린 공식 지원 발표\n- 2017년 5월 구글 IO 에서 안드로이드 공식 지원 언어로 발표\n- 2019년 5월 구글 IO 에서 안드로이드 개발시 최우선 언어 (Kotlin-First) 발표\n- 2022년 5월 코틀린 1.7 베타 릴리즈\n- ...\n\n# 자바에는 있는데 코틀린엔 없는기능\n### 체크드 익셉션(Checked Exception)\n- 자바의 익셉션 계층\n- Throwable : 예외 계층의 최상위 클래스\n- Error : 시스템에 비정상적인 상황이 발생 예측이 어렵고 기본적으로 복구가 불가능 함\n  - e.g) OutOfMemoryError, StackOverflowError, etc\n- Exception : 시스템에서 포착 가능하여 etc (try-catch) 복구 가능\n  - 예외 처리 강제 IOException, FileNotFoundException,\n  - @Transactional 에서 해당 예외가 발생하면 기본적으론 롤백이 동작하지 않음\n    - rollbackFor: 를 사용해야함\n- RuntimeException\n  - 런타임시에 발생하는 예외 예외 처리를 강제하지 않음\n  - e.g ) NullPointerException, ArrayIndexOutOfBoundsException, etc\n\n![img.png](img.png)\n\n- java 에서 체크드 익셉션은 무조건 try catch 로 감싸줘야 하거나 throw 라는 키워드로 예외를 전파하지 않으면 컴파일 에러가 발생.\n```java\ntry {\n    Thread.slepp(1);\n} catch (InterrupedException e) {\n    // 예외처리    \n}\n```\n- kotlin 에서는 체크드 익셉션을 강제 하지 않는다.\n  - 그러나 원한다면 가능하다.\n  - 자바에서 의미없는 체크드 exception 을 지양하는듯해.\n\n### 기본 자료형\n- 자바는 원시 자료형을 지원하며 객체로된 레퍼런스 타입도 지원한다.\n```java\nint i = 0;\nInteger ii = 0;\nString str = ii.toString();\n```\n- 코틀린은 레퍼런스 타입만 지원한다.\n```kotlin\nval i: Int = 0;\nval str: String = i.toString();\n```\n\n- 코틀린의 레퍼런스 타입은 최적화된 방식으로 컴파일 한다.\n```kotlin\nint i = 0;\nString str = String.valueOf(i);\n```\n\n--\n### 정적멤버\n- 자바는 static 키워드로 정적멤버를 선언한다.\n```java\npublic class JavaClass {\n    static int i = 0;\n    \n    public static void staticMethod() {\n        // ...\n    }\n}\n```\n- 코틀린은 companion object 로 대체\n```kotlin\nclass KotlinClass {\n    companion object {\n        val i: Int = 0;\n        fun function() {\n            // ...\n        }\n    }\n}\n```\n\n### 3항 연산자\n- 자바\n```java\nString animalSound = \"호랑이\".equals(animal) ? \"어흥\" : \"야홍\";\n```\n- 코틀린은 if else 로 대체한다.\n```kotlin\nval animalSound: String = if (\"호랑이\" == animal) \"어흥\" : \"야홍\";\n```\n---\n\n### 세미콜론\n- 자바는 무조건 ; 세미콜론이 붙지만 코틀린은 안붙는다.\n```java\nBoolean isAdmin = userService.isAdmin(userId);\n```\n\n```kotlin\nval isAdmin: Boolean = userService.isAdmin(userId)\n```\n\n# 코틀린에는 있는데 자바에는 없는기능\n### 확장\n- 개발자가 임의로 객체의 함수나 프로퍼티를 확장해서 사용할 수 있다.\n\n```kotlin\nfun String.first(): Char {\n    return this[0]\n}\n\nfun String.addFirst(char: Char): String {\n    return char + this.substring(0)\n}\n\nfun main() {\n    println(\"ABCD\".first()) // 출력 A\n    println(\"ABCD\".addFirst('Z')) // 출력 ZABCD \n}\n```\n\n### 데이터 클래스\n- 데이터를 보관하거나 전달하는 목적을 가진 불변 객체로 사용\n\n```kotlin\ndata class Person(val name: String, val age: Int) {\n    // hashCode(), equals(), toString() 자동생성됨\n    // 이외에도 copy(), componentN 도 유용함.\n}\n```\n\n- 기존 자바에선 주로 lombok 을 사용\n\n```java\n@Getter\npublic class Person {\n    private final String name;\n    private final int age;\n}\n```\n\n```kotlin\n// jdk 15 에선 record 라는 이름이 추가됨\npublic record Person(String name, int age) {\n    \n}\n```\n--\n\n# 문자열 템플릿\n- 문자열에 변수를 사용하거나 여러행으로 된 텍스트 블록을 사용 할 수 있다.\n```kotlin\nval text = \"World\"\nval greeting = \"Hello, ${text}\"\n\nprintln(greeting) // Hello, World\n\n//  문자열 템플릿 기반의 다이나믹 쿼리\nfun sql(nameIncluded: Boolean) =\n        \"\"\"\n          SELECT id, name, email, age \n          FROM users \n          WHERE id = :id ${\n                if (nameIncluded) {\n                  \"\"\"\n                  AND name = :name\n                  \"\"\" \n                } else \"\"\n            }\n        \"\"\"\n```\n\n### 기타\n- 스마트 캐스트 실드 클래스 (Jdk15 추가)\n- 위임\n- 중위 표현식\n- 연산자 오버로딩\n- 코루틴\n- etc\n\n\n# 공식문서\n- https://docs.spring.io/spring-framework/reference/web/webmvc/mvc-servlet.html\n- 공식 문서의 샘플 코드를 보면 kotlin 탭을 제공\n\n![img_1.png](img_1.png)\n\n# Spring initializr\n- 기본 언어로 코틀린을 선택할 수 있고 코틀린인 경우 Gradle Project를 선택하면 빌드 설정 을 기반으로 생성해준다\n- Spring initialzr 를 통해 생성된 build.gralde.kts\n\n```gradle\nimport org.jetbrains.kotlin.gradle.tasks.KotlinCompile\n\nplugins { \n    id(\"org.springframework.boot\") version \"2.6.7\" \n    id(\"io.spring.dependency-management\") version \"1.0.11.RELEASE\" \n    kotlin(\"jvm\") version \"1.6.21\" \n    kotlin(\"plugin.spring\") version \"1.6.21\"\n}\n\ngroup = \"com.example\"\n\nversion = \"0.0.1-SNAPSHOT\"\n\njava.sourceCompatibility = JavaVersion.VERSION_11\n\nrepositories { \n    mavenCentral() \n}\n\ndependencies { \n    implementation(\"org.springframework.boot:spring-boot-starter\") \n    implementation(\"org.jetbrains.kotlin:kotlin-reflect\") \n    implementation(\"org.jetbrains.kotlin:kotlin-stdlib-jdk8\") \n    testImplementation(\"org.springframework.boot:spring-boot-starter-test\") \n}\n\ntasks.withType<KotlinCompile> { \nkotlinOptions { \n        freeCompilerArgs = listOf(\"-Xjsr305=strict\") jvmTarget = \"11\" \n    } \n}\n\ntasks.withType<Test> { \n    useJUnitPlatform() \n}\n```\n\n\n- 코틀린 스프링 프로젝트에서 필수적인 플러그인\n  - kotlin(\"plugin.spring\")\n\n- 코틀린 스프링 프로젝트에서 필수적인 의존성\n  - org.jetbrains.kotlin:kotlin-reflect\n  - org.jetbrains.kotlin:kotlin-stdlib\n\n이외에도 plugin.jpa, jackson-module-kotlin 등 프로젝트를 구성하면서 필요한 플러그인 과 <br/>\n코틀린 의존성이 있고 Springinitialzr에서 프로젝트를 구성할 경우 자동으로 세팅해준다\n\n# 스프링 부트\n```\n@SpringBootApplication class DemoApplication\n\n// fun 탑- 레벨 함수이므로 클래스 바깥에서{ 호출\nmain(args: Array<String>) {\n    runApplication<DemoApplication>(*args)\n}\n```\n\n### @ConfigurationProperties\n- 스프링 애플리케이션에 지정한 설정을 기반으로 설정 클래스를 만들때, <br/>\n  @ConstructorBinding 을 사용하면 setter가 아닌 생성자를 통해 바인딩 하므로 <br/>\n  불변 객체를 쉽게 생성할 수 있다.\n\n```kotlin\n@ConstructorBinding\n@ConfigurationProperties(\"example.kotlin\") \n\ndata class KotlinExampleProperties(\n                val name: String,\n                val description: String,\n                val myService: MyService\n                ) {\n\ndata class MyService(\n            val apiToken: String,\n            val uri: URI\n        )\n\n}\n```\n\n### 테스트 지원\n- 기본 제공되는 Junit5 기반의 테스트를 특별한 설정 없이 그대로 사용이 가능하다\n- 모의 객체를 만들어 테스트하려면 Mockito 대신 MockK를 사용할 수 있다"},{"excerpt":"배포 전략","fields":{"slug":"/deploy-strategy/"},"frontmatter":{"date":"November 18, 2022","title":"배포전략","tags":["배포"]},"rawMarkdownBody":"\n# 배포 전략\n"}]}},"pageContext":{}},"staticQueryHashes":[],"slicesMap":{}}