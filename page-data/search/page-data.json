{"componentChunkName":"component---src-pages-search-jsx","path":"/search/","result":{"data":{"allMarkdownRemark":{"nodes":[{"excerpt":"📝 Next.js + Docker + ECR + CloudFront 실전 배포 자동화 배경 회사는 언론사(미디어)라 AMP 지원 필수 였다. 검색엔진 최적화(SEO)와 트래픽 최적화가 필요하게 되어서 배포 진행중 갑자기 문제가 발생했다. App Router + Pages Router 혼용 프로젝트 Docker + ECR + EC2 서버기반 서비스 운영 C…","fields":{"slug":"/docker-deploy/"},"frontmatter":{"date":"April 17, 2025","title":"AMP","tags":["front-end"]},"rawMarkdownBody":"\n# 📝 Next.js + Docker + ECR + CloudFront 실전 배포 자동화\n\n## 배경\n회사는 언론사(미디어)라 AMP 지원 필수 였다.\n\n검색엔진 최적화(SEO)와 트래픽 최적화가 필요하게 되어서 배포 진행중 갑자기 문제가 발생했다.\n\nApp Router + Pages Router 혼용 프로젝트\n\nDocker + ECR + EC2 서버기반 서비스 운영\n\nCDN은 AWS CloudFront 사용 중\n\n## 문제 상황 발생\n기존 수동 Docker Build + Push + 서버 재배포 과정 복잡\n\n서버 Docker OverlayFS 스토리지 드라이버 과부하로 터짐\n\n에러: \"error creating overlay mount... no such file or directory\"\n\n디스크 I/O 병목 발생 → 캐시 레이어 비정상화\n\n빌드 중 중간 레이어가 깨져서 docker-compose up 실패\n\nCDN 캐시 퍼지(purge)도 수동이라\n\n구버전 CSS + 신버전 HTML 섞여 로딩 → 스타일 깨짐 \"\"\"\n\n3. 해결 목표\n\"\"\"text\n\nDockerfile 구조 최적화 (멀티 스테이지 + 퍼미션 오류 제거)\n\n배포 자동화 스크립트 작성 (Build → Push → 서버 업데이트)\n\nCloudFront 캐시 퍼지 스크립트 작성\n\nSlack 배포 결과 알림\n\nDocker OverlayFS 장애 대비 (항상 clean build) \"\"\"\n\n## Dockerfile\n```\n1. 기본 베이스 이미지\nFROM node:20.19.0-alpine AS base\n\nARG NEXT_PUBLIC_ENV ARG NODE_ENV\n\nRUN apk --no-cache add tzdata &&\ncp /usr/share/zoneinfo/Asia/Seoul /etc/localtime &&\necho \"Asia/Seoul\" > /etc/timezone\n\n2. 의존성 설치\nFROM base AS deps WORKDIR /app COPY package.json pnpm-lock.yaml ./ RUN corepack enable && corepack prepare pnpm@10.9.0 --activate && pnpm install --frozen-lockfile\n\n3. 앱 빌드\nFROM base AS builder WORKDIR /app COPY --from=deps /app/node_modules ./node_modules COPY . . RUN corepack enable && corepack prepare pnpm@10.9.0 --activate\n\nENV NODE_ENV=production ENV NEXT_TELEMETRY_DISABLED=1 ENV CSS_MODULES_HASH_PREFIX=stable_ ENV OUTPUT=standalone\n\nARG NEXT_PUBLIC_ENV RUN if [ \"$NEXT_PUBLIC_ENV\" = \"production\" ]; then\ncp ./env/.env.production .env.production;\nelif [ \"$NEXT_PUBLIC_ENV\" = \"staging\" ]; then\ncp ./env/.env.staging .env.production;\nelif [ \"$NEXT_PUBLIC_ENV\" = \"development\" ]; then\ncp ./env/.env.development .env.production;\nelse\ncp ./env/.env.test .env.production;\nfi\n\nRUN pnpm run build\n```\n\n## 런타임\n```\nFROM base AS runner WORKDIR /app\n\nRUN npm install -g pm2 RUN addgroup --system --gid 1001 nodejs && adduser --system --uid 1001 nextjs\n\nCOPY --from=builder --chown=nextjs:nodejs /app/.next/standalone ./ COPY --from=builder --chown=nextjs:nodejs /app/.next/static ./.next/static COPY --from=builder --chown=nextjs:nodejs /app/public ./public COPY --from=builder --chown=nextjs:nodejs /app/public/fonts ./public/fonts COPY --from=builder --chown=nextjs:nodejs /app/.next/server/pages/amp ./.next/server/pages/amp\n\nRUN mkdir -p .next/static/media && chown -R nextjs:nodejs .next\n\nUSER nextjs\n\nEXPOSE 3000 ENV PORT=3000 ENV HOSTNAME=\"0.0.0.0\"\n\nCMD [\"pm2-runtime\", \"start\", \"server.js\", \"-i\", \"2\", \"--max-memory-restart\", \"1536M\"] \"\"\"\n\n```\n\n## 배포 자동화 스크립트 (deploy.sh)\n``` \n#!/bin/bash\n\nset -e\n\nAWS_PROFILE=default AWS_REGION=ap-northeast-2 AWS_ECR_REPOSITORY=537124952818.dkr.ecr.ap-northeast-2.amazonaws.com/kthome-prd-frontend-ecr CLOUDFRONT_DISTRIBUTION_ID=YOUR_CLOUDFRONT_ID SLACK_WEBHOOK_URL=YOUR_SLACK_WEBHOOK_URL NEXT_PUBLIC_ENV=production SERVER_IP=YOUR_SERVER_IP DOCKER_COMPOSE_DIR=/home/ubuntu/deploy-folder\n\nGIT_COMMIT_HASH=$(git rev-parse --short HEAD) IMAGE_TAG=$GIT_COMMIT_HASH\n\necho \"🚀 배포 시작 (태그: $IMAGE_TAG)\"\n\ndocker build --build-arg NEXT_PUBLIC_ENV=$NEXT_PUBLIC_ENV -t $AWS_ECR_REPOSITORY:$IMAGE_TAG . aws ecr get-login-password --region $AWS_REGION | docker login --username AWS --password-stdin $AWS_ECR_REPOSITORY docker push $AWS_ECR_REPOSITORY:$IMAGE_TAG\n\nssh ubuntu@$SERVER_IP << EOF cd $DOCKER_COMPOSE_DIR sed -i \"s|image: .*|image: $AWS_ECR_REPOSITORY:$IMAGE_TAG|\" docker-compose.yml docker-compose pull docker-compose up -d --remove-orphans EOF\n\naws cloudfront create-invalidation --distribution-id $CLOUDFRONT_DISTRIBUTION_ID --paths\n\"/_next/data/\" \"/_next/static/\" \"/favicon.ico\" \"/robots.txt\" \"/sitemap.xml\" \"/index.html\"\n\ncurl -X POST -H 'Content-type: application/json' --data \"{ \"text\": \"✅ 배포 완료: $IMAGE_TAG\", \"attachments\": [ { \"color\": \"#36a64f\", \"fields\": [ { \"title\": \"배포 서버\", \"value\": \"$SERVER_IP\", \"short\": true }, { \"title\": \"태그\", \"value\": \"$IMAGE_TAG\", \"short\": true } ] } ] }\" $SLACK_WEBHOOK_URL\n\necho \"✅ 전체 배포 완료!\"\n```\n\n## Docker OverlayFS 이슈 대응 방법\nDocker Build 시 --no-cache 옵션 사용 습관화\n\n오래된 dangling 이미지 주기적 제거 (ex: docker system prune -af)\n\n디스크 공간 부족 대비 → EBS 확장 정책 준비\n\n대규모 프로젝트 빌드 시 layer 수 줄이기 \"\"\"\n\n## 최종 정리\n배포 자동화 성공\n\n서버 깨짐(overlay2 디스크 에러) 복구\n\nAMP SEO + 일반 SEO 대응 완비\n\nSlack 실시간 배포 알림 연동\n\nECR + EC2 + CloudFront 캐시 퍼지 자동화 완료\n\n\n"},{"excerpt":"🗞️ 한 달간의 뉴스 사이트 프론트 성능 최적화✨ 현재 한 언론사에서 뉴스 웹사이트 운영과 성능 최적화를 진행하고 있다. 뉴스 기사의 검색 노출 최적화는 단순한 트래픽을 넘어 광고 수익과 직결되는 핵심 과제다. 어찌 보면 당연한 이야기처럼 들릴 수 있다. 기사를 작성해 발행하면 포털이나 구글 검색에 잘 뜨는 것 이 기본이니까.   아 물론, 내가 기본이라고…","fields":{"slug":"/performance/"},"frontmatter":{"date":"April 17, 2025","title":"뉴스 웹사이트, 퍼포먼스로 살아남기","tags":["front-end","performance","next.js","core-web-vitals"]},"rawMarkdownBody":"\n![performance.png](img.png)\n\n## 🗞️ 한 달간의 뉴스 사이트 프론트 성능 최적화✨\n현재 한 언론사에서 뉴스 웹사이트 운영과 성능 최적화를 진행하고 있다.  \n뉴스 기사의 **검색 노출 최적화**는 단순한 트래픽을 넘어 **광고 수익**과 직결되는 핵심 과제다.\n\n어찌 보면 당연한 이야기처럼 들릴 수 있다.    \n기사를 작성해 발행하면 포털이나 구글 검색에 *잘 뜨는 것 이 기본이니까*.\n\n![img_1.png](img_1.png)\n\n 아 물론, 내가 기본이라고 말했던 오만함의 **잘** 의 조건은 다음과 같다.\n\n## 🔧 검색 노출을 위한 기술 요소 정리표\n\n| 항목 | 설명 |\n|------|------|\n| **Core Web Vitals** | 구글이 정한 '웹사이트 건강검진 3종 세트 (LCP, CLS, INP)' |\n| **AMP 지원** | 모바일 최적화를 위한 프레임워크. 초고속 로딩으로 이탈률을 낮춰준다 |\n| **구조화 메타태그** | SNS 공유 시 미리보기 제공 + 검색 결과에 부가 정보 표시 가능 |\n| **반응형 이미지 최적화** | 각 디바이스별로 가장 적절한 해상도의 이미지를 제공 |\n| **코드 스플릿팅** | 페이지별로 필요한 코드만 로딩 → 초기 랜딩 속도 개선 |\n| **경량 이미지** | CDN `w=` 파라미터 조절로 화질은 유지하며 용량은 줄임 |\n| **Lazy Load** | 화면에 들어오기 전까지 이미지/광고 스크립트를 로딩하지 않음 |\n\n\n- 등등 ..\n\n개선해 나아간 부분들이 정말 다행스럽다. 프론트엔드 고수분들을 진심으로 존경하고 존경한다.\n\n---\n## 불안하다 했다.\n\n퇴사후 한달간의 리프레쉬 기간을 갖고, 어찌저찌 현 회사에 투입이 되었다.\n\n구축 외주 인력 분들이 철수하게 되어, 운영에 필요한 인수인계를 받으면 되었다.   \n\n가벼운 마음으로 모닝 커피 마시면서 한분 한분 인사를 드렸다.  \n( 휴식후 너무 오랜만에 사람을 만나서 반가웠고 많이 웃었다.)\n\n그리고 곧 철수하는 분들에게 부럽다는 표정을 숨기고, 잔여 이슈에 대해서 설명하는 시간을 가지기로 하며,\n순조롭게 인수인계를 받을 준비를 하며 노트북을 키는 순간이였다. \n\n( 왜이렇게 순조롭지 라는 생각이 들때쯤. 상사 분의 스윗 + 다급한 목소리 )\n\n**\"형기 씨 ... 정말 미안한데, 급해.\"**\n\n![img_2.png](img_2.png)\n---\n\n## AMP 뭔데요?\n부장님께서 호출하신 이유는 AMP 페이지가 정상적으로 동작하지 않는 심각한 이슈가 있어, 이를 분석후 걷어내야 할지 개선해서 사용할지를 검토를 해달라고 하셨다.  \n\nAMP 가 뭔지도 모르는 나는 잠깐의 히스토리 설명을 듣고 반나절 정도 분석후 검토할 시간을 달라고 말씀드렸다.  \n( 쪼금만 기다려주세요 입사 첫날이라서요.. )\n\n> 📦 AMP 란?\n> - AMP는 Accelerated Mobile Pages의 줄임말로, 모바일 웹 페이지를 더 빠르게 로딩하기 위한 오픈소스 프레임워크 이다.\n> - 구글이 주도해서 만들었고, 현재는 다양한 회사와 커뮤니티가 함께 관리되고 있다.  \n> - 빠른 로딩 속도 + 안정적인 사용자 경험으로, 특히 뉴스/블로그/미디어 사이트에 매우 강력한 효과를 준다.\n>\n> 🔐 AMP 는 운영중 제약이 많아 요즘엔 **Core Web Vitals 을 통해 대체하는 추세** 이다.  \n\n현재 도메인 특성에 맞는 기술인지 판단하고, 개선하면 되는 것을 잘 알기에 조금만 더 digging 을 해보았다. \n( <strike> 구글이 만든 기술이니 구글에 맞는 스킬이겠지. </strike> )\n\n📉 AMP 단점 요약\n\n| 구분      | 단점 내용                   |\n| ------- |-------------------------|\n| 🧩 기능 | JS 사용 제한, 커스텀 기능 구현 어려움 |\n| 🎨 디자인  | CSS 용량 제한, 커스터마이징 불편    |\n| 🧪 개발 경험 | 디버깅 어려움, validator 의존   |\n| 💼 운영 부담 | AMP 따로 만들고 유지 → 리소스 증가  |\n| 🛰️ 종속성 | 구글 캐시 도메인 문제, 유입 분석 어려움 |\n\n> 제약이 있다는 말은 사용하지 못한다는 것이 아니라, amp 규칙에 맞는 문법으로 대체 해야 한다는 뜻이다. ( 그들만의 로마법 을 따라야 함이 불.편. )\n\n예를 들어, js 를 사용하고 싶다면, 아래와 같이 사용해야 한다.\n```html\n<amp-script layout=\"container\" src=\"https://당신의-회사-cdn-주소-혹은-프로젝트-내에-별도-스크립트-파일이-필요합니다-젠장/script.js\">\n  <p>이곳에 스크립트가 삽입됨.</p>\n</amp-script>\n```\n\n⚡ AMP 장점 요약   \n\n| 구분                 | 장점 내용                                               |\n| ------------------ | --------------------------------------------------- |\n| 🚀 속도              | AMP는 로딩 속도가 **압도적으로 빠름** (HTML + 제한된 JS/CSS만 허용)    |\n| 📱 사용자 경험          | 기본적으로 Lazy Load + Viewport 우선 렌더링 → **UX 최적화**      |\n| 🔍 검색 최적화          | **구글 AMP 캐시**에 의해 빠른 응답 + 검색 상단 노출 가능성 증가           |\n| 💎 Core Web Vitals | LCP, CLS, INP 등 **성능 지표 자동 개선 효과**                  |\n| 📈 SEO/트래픽         | 빠른 로딩 + UX 개선 → **이탈률 감소 + 유입 증가**                  |\n| 🧰 내장 컴포넌트         | `amp-img`, `amp-carousel` 등으로 **인터랙션을 JS 없이 구현 가능** |\n| 🧵 일관성             | AMP validator 통과 필수 → **표준화된 코드와 구조 강제**로 QA 부담 감소  |\n\n\n🤔 현재 도메인에 AMP 적합성 요약  \n\n현재 운영 중인 웹사이트는 기사 본문 중심의 뉴스 사이트다. 즉, 동적인 UI보다는 텍스트 콘텐츠 위주로 구성되어 있다.  \n\n사용자가 본문을 한 번 로드한 이후에는 인터랙션이 거의 없는 만큼 사용자 경험이 단순하고, 정적 콘텐츠 중심인 구조다.  \n\n이런 특성의 사이트는 AMP의 제약과 잘 맞는다.\n복잡한 JS 상호작용이 거의 없고 페이지의 빠른 로딩과 안정적인 레이아웃이 더 중요하기 때문이다.\n\n\n| 유형                   | AMP 적합도 | 이유                                       |\n| -------------------- | ------- | ---------------------------------------- |\n| 📰 뉴스, 미디어, 퍼블리싱 플랫폼 | ✅ 매우 적합 | 정적 콘텐츠 중심 + 검색 유입이 중요                    |\n| 🛍️ 쇼핑몰, 커뮤니티, SaaS  | ⚠️ 부적합  | 동적 UI, 사용자 상호작용 많음                       |\n| 📅 2024 이후           | 선택적 적용  | 구글이 AMP 강제 ↓, 다만 여전히 Top Stories 노출은 유리함 |\n\n🥰 국내 뉴스 유입이 포털 중심에서 검색 중심으로 넘어오고 있다는 사실.\n\n물론 한국은 네이버·다음 같은 **포털 중심의 뉴스 소비 성향**이 강하다.  \n하지만 최근에는 **구글 검색 + 유튜브 검색을 통한 뉴스 소비도 꾸준히 증가 중**이다.\n\n> 특히 검색 기반 유입은 ‘롱테일 콘텐츠’ 확보에 핵심.  \n> 반면, 포털 메인은 *경쟁도 심하고, 노출 타이밍도 예측이 불가능*\n\n---\n\n오케이 🙆 도메인 적합성 + amp 배경지식 습득 완료 . 그럼 이제 트러블 슈팅 을 해보자.\n\n![img_4.png](img_4.png)\n\n앞서 말했듯이 **AMP는 정적 검증기 인 AMP Validator 를 통과해야만 페이지가 동작 가능** 한데, 본문에 허용하지 않는 Tag 가 선언되어 있거나,    \n./next/static 하위 js 번들이 포함되어 있으면 AMP 페이지가 정상적으로 동작하지 않는다.\n- [Next.js AMP 공식 문서](https://nextjs.org/docs/app/building-your-application/routing/pages-and-layouts#amp)\n\n\n그러나, 문제의 *태그* 를 해결해도 왜 next 번들 파일이 guide 규칙에 걸리는지 의문을 품던 도중   \n\n❗ AMP는 Next.js의 pages 라우터 기반에서만 정식 지원하고, app router 기반에서는 공식적으로 AMP 지원이 되지 않는다는 사실을 알았다.    \n\n![img_5.png](img_5.png)\n\n이런 ;; 마치 샌드위치 속 재료는 다 바꿨는데, 포장지가 비닐이 아니라 종이여야 했던 걸 몰랐던 상황처럼.\n\n![img_3.png](img_3.png)\n\n그런줄도 모르고 되게 얄미워했네. 열받게.\n\n천만 다행으로, Next.js 13 버전 부터 app router 가 도입되었고, 현재는 app router 가 기본으로 사용되고 있으나 점진적 전환을 위해 pages 를 열어둔게 극적...\n\n결론은. 할 수 있다.\n"},{"excerpt":"amp AMP(Accelerated Mobile Pages)는 빠른 로딩을 위해 엄격한 제약을 두는 프레임워크입니다. Next.js에서 AMP를 적용할 때도 이러한 제한이 그대로 적용됩니다. useHook (React Hook) 사용 제한 AMP 자체는 React의 훅 사용을 직접적으로 제한하지 않습니다. 하지만, AMP 페이지는 클라이언트 측에서 실행되…","fields":{"slug":"/amp/"},"frontmatter":{"date":"April 17, 2025","title":"AMP","tags":["front-end"]},"rawMarkdownBody":"\n### amp\nAMP(Accelerated Mobile Pages)는 빠른 로딩을 위해 엄격한 제약을 두는 프레임워크입니다. Next.js에서 AMP를 적용할 때도 이러한 제한이 그대로 적용됩니다.\n\n1. useHook (React Hook) 사용 제한\n\nAMP 자체는 React의 훅 사용을 직접적으로 제한하지 않습니다.\n\n하지만, AMP 페이지는 클라이언트 측에서 실행되는 JavaScript(특히 커스텀 JS)를 거의 허용하지 않으므로,\nReact Hook을 이용해 동적으로 상태를 변경하거나, 효과를 실행하는 로직이 AMP 페이지에서 동작하지 않습니다.\n\nAMP 페이지는 기본적으로 정적이어야 하며, 동적 인터랙션은 AMP에서 제공하는 컴포넌트(예: amp-bind, amp-form 등)로만 구현할 수 있습니다.\n\n2. Sass 방식의 스타일링 제한\n\nNext.js는 Sass(.scss, .sass) 및 CSS Modules를 지원하지만,\nAMP 페이지에서는 CSS-in-JS만 지원됩니다.\n\nSass, CSS Modules, 글로벌 CSS 등은 AMP 페이지에서 사용할 수 없습니다.\n\nAMP에서는 <style amp-custom> 태그를 통해 75KB 이내의 인라인 CSS만 허용하며,\nNext.js의 AMP 페이지에서는 styled-components, emotion과 같은 CSS-in-JS 방식만 정상적으로 동작합니다.\n\nSass로 작성한 스타일을 AMP 페이지에 적용하려면, CSS-in-JS로 변환하거나,\n<style amp-custom>을 직접 <Head>에 넣는 식으로만 제한적으로 사용할 수 있습니다.\n\n3. <script> 태그 사용 제한\n\nAMP는 커스텀 JavaScript를 절대적으로 금지합니다.\n\n<script> 태그는 오직 AMP에서 공식적으로 제공하는 컴포넌트 로딩(예: <script async custom-element=\"amp-img\" ...>) 용도로만 허용됩니다.\n\n개발자가 직접 작성한 JavaScript를 AMP 페이지에 삽입하면 AMP 검증에서 실패합니다.\n\nNext.js AMP 페이지에서도 <script>를 자유롭게 쓸 수 없으며,\n필요한 경우 next/head를 통해 공식 AMP 컴포넌트만 추가할 수 있습니다."},{"excerpt":"Rag (Retrieval Augmented Generation) 의 탄생 배경 RAG 은 대규모 언어 모델(LLM)의 한계를 극복하기 위해 개발된 기술로, 검색과 생성의 결합을 통해, 작업에서 정확하고 맥락에 맞는 답변을 생성하거나. 최신 정보와 특정 도메인 데이터를 동적으로 활용할 수 있도록 설계된 기술이다. LLM 은 어떤 한계를 가졌을까 ? LLM…","fields":{"slug":"/rag/"},"frontmatter":{"date":"March 29, 2025","title":"Rag","tags":["AI"]},"rawMarkdownBody":"\n## Rag (Retrieval Augmented Generation) 의 탄생 배경\n**RAG** 은 대규모 언어 모델(LLM)의 한계를 극복하기 위해 개발된 기술로, 검색과 생성의 결합을 통해, 작업에서 정확하고 맥락에 맞는 답변을 생성하거나. 최신 정보와 특정 도메인 데이터를 동적으로 활용할 수 있도록 설계된 기술이다.\n\n## LLM 은 어떤 한계를 가졌을까 ?\nLLM 의 한계는 학습 데이터를 기반으로 응답을 생성하다 보니, 새로운 정보나 특정 도메인 지식에 대한 질문에 대한 질의 응답을 할수가 없었다. 만약 한다 하더라도 AI 헛소리 라고 불리우는 **할루시네이션** 문제가 발생하였다. 즉, **거짓말** 이다.\n\n## RAG 의 탄생 배경\n2020년 9월 28일 Meta AI 연구진이 발표한 논문 *\"Retrieval-Augmented Generation for Knowledge-Intensive NLP Tasks\"*를 통해 처음 소개되었다. <br/> \n이 연구는 Facebook AI Research(현재 Meta AI), University College London, 그리고 New York University의 협력으로 이루어졌다. <br/> \n주요 저자는 Patrick Lewis를 포함한 여러 연구진으로, 이들은 기존 LLM이 가진 정적 데이터 의존성과 할루시네이션(hallucination) 문제를 해결하기 위해 RAG를 개발했다. <br/>\n외부 데이터베이스나 문서 저장소 등에서 관련 정보를 검색하고 이를 기반으로 응답을 생성하는 구조를 채택했다.\n\n## RAG의 작동 방식\n- 검색(retrieval): 사용자가 입력한 질문에 따라 관련된 지식을 외부 데이터베이스나 문서에서 검색한다.\n- 생성(generation): 검색된 정보를 **통합**하여 **적절한 텍스트**로 생성한다. ( 맥락에 맞는 답변 )\n- 증강(augmentation): 검색된 데이터를 LLM의 입력 프롬프트에 추가하여 응답의 품질을 높인다.\n\n## RAG의 주요 특징\n- **동적 정보 활용**: 정적 학습 데이터에 의존하지 않고 최신 정보를 반영할 수 있다.\n- **효율성**: 모델 전체를 재학습하지 않아도 외부 데이터베이스만 업데이트하면 된다.\n- **신뢰도 향상**: 검색된 데이터를 기반으로 응답을 생성해 할루시네이션 문제를 완화한다.\n\n\"검색(retrieval)\"과 \"생성(generation)\"을 결합한 구조를 도입 함으로써, 사용자의 입력에 따라 외부 지식 베이스(예: 데이터베이스, 문서 저장소)에서 관련 정보를 검색하고, 이를 기반으로 더욱 정확하고 맥락에 맞는 응답을 생성하게 되었다.\nRAG는 정적 데이터에 의존하지 않고 동적으로 정보를 활용할 수 있는 능력을 갖추게 된다."},{"excerpt":"아이스 브레이킹 22 년 어느날, Back-end 개발자로 개발생활을 영위하며 바쁜 일상생활을 보내고 있었던 🍁가을무렵 이였다. 헤성처럼 나타나 개발자들에게 \"코더 계속 하실 ?\" 이라는 극딜을 준 G 선생. 솔직히 처음 모델만 해도 리펙토링 정도만 살짝 참고하는 정도여서 전혀 히지 않았다. 분명 그랬을 터인데, 24년 여름쯤 이였다. 일정 테트리스로 인…","fields":{"slug":"/spring-ai/"},"frontmatter":{"date":"March 29, 2025","title":"Ai. Spring AI 로 때워도 되나유? 1편","tags":["AI","Spring"]},"rawMarkdownBody":"\n## 아이스 브레이킹\n\n22 년 어느날, Back-end 개발자로 개발생활을 영위하며 바쁜 일상생활을 보내고 있었던 🍁가을무렵 이였다. 헤성처럼 나타나 개발자들에게 *\"코더 계속 하실 ?\"* 이라는 극딜을 준 G 선생. 솔직히 처음 모델만 해도 리펙토링 정도만 살짝 참고하는 정도여서 전혀 `긁`히지 않았다. 분명 그랬을 터인데, 24년 여름쯤 이였다. 일정 테트리스로 인하여 여러 프로젝트가 겹쳐 시간이 빠듯하였고 결국 생성형 AI 를 적극 활용하기로 하였다. 그 결과 무려 10배 혹은 20배나 되는 `생산성의 맛` 을 봐 버렸고. 요망한 AI 에게 의존하는 삶을 살게 되었다.\n![ㅎ...형!!!](image-2.png)\n\n의존 하다보니 느끼는 감정은 날것 그대로 쓰기엔 오류도 많고 아직 사람손이 타야하는 영역이 많긴한데, 점점 그 빈도가 **줄어들고 있다는 점**에서 불안과 걱정의 씨앗이 심어졌다. 정말 어느 순간 모르게 급격하게 발전해서 **\"비즈니스 영역까지 커버하게 된다면\"** 더이상 내 자신이 회사에 필요하지 않게될 날이 도래하겠다는 생각이 들었다. \"에이 ~ AI 는 아직 부족한 부분이 많으니 대체되지 않을거야\" 라는 **미련을 빨리 버려야 된다**고 생각했다. 그러나 처음부터 AI 의 모든 영역을 공부하기엔 현실적으로 많은 러닝커브가 따르고 막막하여 생각에 잠긴다.\n\n> 1️⃣ Web 개발자 관점에서 AI 를 활용하기 위해 어떤 개념들을 알아야 할까 🤔 ? <br/>\n> 2️⃣ Spring AI 가 있다는데, python 없이도 AI 기술들을 커버할 수 있는걸까 🤔 ? <br/>\n> 3️⃣ 많이 뒤쳐진것 같아 불안해. 빠르게 AI 기술들을 적용해보고 싶어 ‼️ <br/>\n\n## 돈워리. Web 개발자 관점에서 요구되는 AI 기술 부터\n웹 개발자는 AI 모델을 직접 연구하거나 신경망을 설계하는 사람이 아니다. **AI를 활용하여 제품을 개발하고 사용자 경험을 향상시키는 데 초점**을 맞추어야 한다. 단, 요구되는 지식은 다음과 같다.\n\n- **AI 기술 이해**: ( 머신러닝 딥러닝 기본 개념 ), AI 모델 작동 방식\n- **API 및 라이브러리 활용**: openAi API 과 같은 도구를 사용하여 애플리케이션에 AI 기능 통합\n- **멀티모달 데이터 처리**: 텍스트, 이미지, 음성 등 다양한 데이터를 처리하여 사용자 경험 개선\n- **데이터 기반 의사결정**: 사용자 데이터를 분석하고 이를 기반으로 제품 설계 및 최적화.\n\n> 기술의 발전과 패러다임을 보면 항상 사용자에게 시간을 준다. 딱 5년. 2년도 안남았네 .. <br/>\n> 🏃🏿 지금부터 SpringAI 를 기점으로 AI 와 빠르게 친해지는 길로 달려보는 수 밖에.\n\n\n## Spring AI란 무엇인가?\n\n![출처 - https://spring.io/projects/spring-ai](image-3.png)\nSpring AI는 Java 개발자를 위한 AI 통합 프레임워크다. 기존에 AI 기능을 추가하려면 Python, 머신 러닝, 딥 러닝에 대한 광범위한 지식이 필요했는데 Spring AI를 사용하면 개발자가 OpenAI의 GPT-4 및 DALL-E 3의 기능을 쉽 게 활용할 수 있어, Java 개발자가 복잡한 인공 지능 기능에 액세스 할 수 있게 되었다. Spring 기술과 자연스럽게 연결되기 때문에 AI 기술을 `처음부터` 배우지 않아도 된다.\n\n## 왜 Spring AI로 시작해야 할까?\n\nSpring AI는 복잡한 AI 기술을 Java 개발자가 쉽게 접근할 수 있도록 단순화 되어있다. 굳이 채택하려는 이유라고 하면 다음과 같다.\n- **효율성**: 기존 Spring 생태계를 활용해 빠르게 시작 가능.\n- **확장성**: 다양한 모델과 데이터베이스를 유연하게 교체 및 확장 가능.\n- **생산성 향상**: 반복 작업을 자동화하고, 개발자가 중요한 문제 해결에 집중할 수 있도록 도움.\n\n## Spring AI로 무엇을 만들 수 있을까?\n\nSpring AI를 활용하면 다음과 같은 애플리케이션을 개발할 수 있다.\n- RAG 기반 검색 시스템: 질문에 대해 정확한 답변을 제공하는 검색 엔진.\n- 대화형 챗봇: OpenAI GPT-4와 연동된 스마트 대화 시스템.\n- 이미지 분석 및 생성: 멀티모달 기능을 활용한 이미지 처리 애플리케이션.\n\n> Toy Project 딱대 🥰  마지막으로 Spring AI 의 주요 기능과 설명으로 이번 포스팅을 마치며, <br/> 대화형 chat api 를 open ai 를 활용하여 toy project 를 다루는 방향으로 2 편을 작성해보려고 한다.\n\n## 주요 기능 과 설명\n| 기능                              | 설명                                                                 | 장점                                                                                       |\n|--------------------------------------|-----------------------------------------------------------------------------|--------------------------------------------------------------------------------------------------|\n| Boot Auto Configuration Support      | Spring Boot와의 통합으로 AI 기능을 쉽게 설정할 수 있다.                     | 복잡한 설정 코드를 줄여 개발 속도를 높인다.                                                            |\n| Multiple AI Support                  | OpenAI, Hugging Face, Google BERT 등 여러 AI 모델을 쉽게 사용할 수 있다.    | 다양한 AI 모델 간의 비교와 최적화를 쉽게 수행할 수 있으며, 모델 변경 시 코드 수정이 최소화된다.                        |\n| ChatClient API                       | AI와 대화하는 기능을 쉽게 구현할 수 있다.                                  | 대화형 AI 애플리케이션을 쉽게 구축할 수 있으며, 사용자와의 상호작용을 원활하게 처리한다.                             |\n| Prompt Template                      | 프롬프트 템플릿을 통해 AI에 보낼 입력값을 쉽게 조정할 수 있다.               | 코드의 재사용성을 높이고, 다양한 요구 사항에 맞는 질의를 손쉽게 작성할 수 있다.                                    |\n| Vector Embedding and Search          | 문서를 벡터화하고, 벡터 검색을 통해 고성능 검색 엔진을 구현할 수 있다.       | 복잡한 데이터를 효율적으로 검색하고 분석할 수 있으며, 이는 정보 검색 및 추천 시스템에 유용하다.                        |\n| Advisors API                         | 반복적인 생성 AI 패턴을 캡슐화하고, 데이터를 변환하여 다양한 모델과 사용 사례에 걸쳐 이식성을 제공한다. | AI 애플리케이션의 구조적 설계를 간소화하고, 성능을 최적화하며, 변화하는 요구사항에 빠르게 적응할 수 있다.              |\n| Retrieval Augmented Generation (RAG) | 정보 검색과 생성 AI를 결합하여 더 정확하고 신뢰할 수 있는 콘텐츠를 생성하는 기술을 지원한다. | 대규모 언어 모델의 한계를 보완하여 질문에 대한 더 정확한 답변을 제공한다.                                        |\n| Observability and Model Evaluation   | AI 관련 작업에 대한 통찰력을 제공하고, 생성된 콘텐츠의 품질을 평가하는 도구를 지원한다. | AI 모델의 성능을 모니터링하고, 잘못된 응답을 방지하여 시스템의 신뢰성을 높인다.                                        |\n\n---\n"},{"excerpt":"Redis 를 활용한 분산 lock","fields":{"slug":"/basic/"},"frontmatter":{"date":"April 02, 2024","title":"Redis","tags":["Redis"]},"rawMarkdownBody":"\n## Redis 를 활용한 분산 lock\n\n"},{"excerpt":"코들린의 현재와 미래 코틀린을 배워야하는 이유 코틀린은 IntelliJ로 유명한 젯브레인사에서 만든 언어이기 때문에 IntelliJ에서 자동완성, 자 바-코틀린 변환, 코루틴 등 코틀린 관련 편의 기능을 완벽하게 지원 자바는 발표된지 20년이 넘었지만 코틀린, C#, 스위프트와 같은 현대적 언어에 비해 기능 이 부족함 자바에서 Best-Practice로 …","fields":{"slug":"/kotlin/"},"frontmatter":{"date":"January 12, 2024","title":"코틀린의 현재와 미래","tags":["코틀린"]},"rawMarkdownBody":"\n# 코들린의 현재와 미래\n### 코틀린을 배워야하는 이유\n- 코틀린은 IntelliJ로 유명한 젯브레인사에서 만든 언어이기 때문에 IntelliJ에서 자동완성, 자 바-코틀린 변환, 코루틴 등 코틀린 관련 편의 기능을 완벽하게 지원\n- 자바는 발표된지 20년이 넘었지만 코틀린, C#, 스위프트와 같은 현대적 언어에 비해 기능 이 부족함\n- 자바에서 Best-Practice로 불리는 기법들을 언어적 차원에서 기본 제공\n- 자바에 비해 문법이 간결하기 때문에 가독성과 생산성이 높고 오류 가능성이 적어진다\n\n```kotlin\ndata class Person(\n        val name: String, \n        val age: Int, \n        val email: String\n) // equals(), hashCode(), toString() 등 유용한 함수를 자동 생성\n\nobject MyCompany { // 싱글턴 객체 \n    const val name: String = \"MyCompany\"\n}\n\n// 탑- 레벨 함수로 클래스 외부에서 함수 작성 가능\nfun main() {\n    // `new` 키워드 없이 객체 생성\n    val person = Person(\"이상훈 \", 35, \" digimon1740 @gmail.com \")\n}\n```\n\n### 좀더 파해쳐 보자\n- 문법 간결\n- data class 라는 기능을 사용하게 되면\n  - 자동으로 equals, hashcode, toString 을 자동으로 생성함\n- object 라는 키워드를 사용하게되면\n  - 간단하게 싱글턴 객체를 만들어준다.\n- 함수를 탑 레벨에 위치\n  - 탑 레벨 함수는 클래스 외부에서 함수를 작성할 수 있는 기능이다. ( 별도의 클래스 없이 작성가능 )\n  - 반면 자바에서는 기본적으로 클래스를 만들고 그 안에서 메서드를 만든다.\n- new 키워드 없이 객체를 만들 수 있다.\n- 멀티 플랫폼 언어이다\n  - 서버개발\n  - e.g ) 모바일 앱, 프론트 js, 안드로이드\n\n### 기업의 개선점\n- google 의 경우 npe 를 33% 절감 함\n- 그로인해 사용자 환경은 크게 향상 시켰다.\n\n### 코틀린 타임라인\n- 2016년 2월 코틀린 1.0 릴리즈\n- 2017년 1월 스프링 프레임워크 5.0 부터 코틀린 공식 지원 발표\n- 2017년 5월 구글 IO 에서 안드로이드 공식 지원 언어로 발표\n- 2019년 5월 구글 IO 에서 안드로이드 개발시 최우선 언어 (Kotlin-First) 발표\n- 2022년 5월 코틀린 1.7 베타 릴리즈\n- ...\n\n# 자바에는 있는데 코틀린엔 없는기능\n### 체크드 익셉션(Checked Exception)\n- 자바의 익셉션 계층\n- Throwable : 예외 계층의 최상위 클래스\n- Error : 시스템에 비정상적인 상황이 발생 예측이 어렵고 기본적으로 복구가 불가능 함\n  - e.g) OutOfMemoryError, StackOverflowError, etc\n- Exception : 시스템에서 포착 가능하여 etc (try-catch) 복구 가능\n  - 예외 처리 강제 IOException, FileNotFoundException,\n  - @Transactional 에서 해당 예외가 발생하면 기본적으론 롤백이 동작하지 않음\n    - rollbackFor: 를 사용해야함\n- RuntimeException\n  - 런타임시에 발생하는 예외 예외 처리를 강제하지 않음\n  - e.g ) NullPointerException, ArrayIndexOutOfBoundsException, etc\n\n![img.png](img.png)\n\n- java 에서 체크드 익셉션은 무조건 try catch 로 감싸줘야 하거나 throw 라는 키워드로 예외를 전파하지 않으면 컴파일 에러가 발생.\n```java\ntry {\n    Thread.slepp(1);\n} catch (InterrupedException e) {\n    // 예외처리    \n}\n```\n- kotlin 에서는 체크드 익셉션을 강제 하지 않는다.\n  - 그러나 원한다면 가능하다.\n  - 자바에서 의미없는 체크드 exception 을 지양하는듯해.\n\n### 기본 자료형\n- 자바는 원시 자료형을 지원하며 객체로된 레퍼런스 타입도 지원한다.\n```java\nint i = 0;\nInteger ii = 0;\nString str = ii.toString();\n```\n- 코틀린은 레퍼런스 타입만 지원한다.\n```kotlin\nval i: Int = 0;\nval str: String = i.toString();\n```\n\n- 코틀린의 레퍼런스 타입은 최적화된 방식으로 컴파일 한다.\n```kotlin\nint i = 0;\nString str = String.valueOf(i);\n```\n\n--\n### 정적멤버\n- 자바는 static 키워드로 정적멤버를 선언한다.\n```java\npublic class JavaClass {\n    static int i = 0;\n    \n    public static void staticMethod() {\n        // ...\n    }\n}\n```\n- 코틀린은 companion object 로 대체\n```kotlin\nclass KotlinClass {\n    companion object {\n        val i: Int = 0;\n        fun function() {\n            // ...\n        }\n    }\n}\n```\n\n### 3항 연산자\n- 자바\n```java\nString animalSound = \"호랑이\".equals(animal) ? \"어흥\" : \"야홍\";\n```\n- 코틀린은 if else 로 대체한다.\n```kotlin\nval animalSound: String = if (\"호랑이\" == animal) \"어흥\" : \"야홍\";\n```\n---\n\n### 세미콜론\n- 자바는 무조건 ; 세미콜론이 붙지만 코틀린은 안붙는다.\n```java\nBoolean isAdmin = userService.isAdmin(userId);\n```\n\n```kotlin\nval isAdmin: Boolean = userService.isAdmin(userId)\n```\n\n# 코틀린에는 있는데 자바에는 없는기능\n### 확장\n- 개발자가 임의로 객체의 함수나 프로퍼티를 확장해서 사용할 수 있다.\n\n```kotlin\nfun String.first(): Char {\n    return this[0]\n}\n\nfun String.addFirst(char: Char): String {\n    return char + this.substring(0)\n}\n\nfun main() {\n    println(\"ABCD\".first()) // 출력 A\n    println(\"ABCD\".addFirst('Z')) // 출력 ZABCD \n}\n```\n\n### 데이터 클래스\n- 데이터를 보관하거나 전달하는 목적을 가진 불변 객체로 사용\n\n```kotlin\ndata class Person(val name: String, val age: Int) {\n    // hashCode(), equals(), toString() 자동생성됨\n    // 이외에도 copy(), componentN 도 유용함.\n}\n```\n\n- 기존 자바에선 주로 lombok 을 사용\n\n```java\n@Getter\npublic class Person {\n    private final String name;\n    private final int age;\n}\n```\n\n```kotlin\n// jdk 15 에선 record 라는 이름이 추가됨\npublic record Person(String name, int age) {\n    \n}\n```\n--\n\n# 문자열 템플릿\n- 문자열에 변수를 사용하거나 여러행으로 된 텍스트 블록을 사용 할 수 있다.\n```kotlin\nval text = \"World\"\nval greeting = \"Hello, ${text}\"\n\nprintln(greeting) // Hello, World\n\n//  문자열 템플릿 기반의 다이나믹 쿼리\nfun sql(nameIncluded: Boolean) =\n        \"\"\"\n          SELECT id, name, email, age \n          FROM users \n          WHERE id = :id ${\n                if (nameIncluded) {\n                  \"\"\"\n                  AND name = :name\n                  \"\"\" \n                } else \"\"\n            }\n        \"\"\"\n```\n\n### 기타\n- 스마트 캐스트 실드 클래스 (Jdk15 추가)\n- 위임\n- 중위 표현식\n- 연산자 오버로딩\n- 코루틴\n- etc\n\n\n# 공식문서\n- https://docs.spring.io/spring-framework/reference/web/webmvc/mvc-servlet.html\n- 공식 문서의 샘플 코드를 보면 kotlin 탭을 제공\n\n![img_1.png](img_1.png)\n\n# Spring initializr\n- 기본 언어로 코틀린을 선택할 수 있고 코틀린인 경우 Gradle Project를 선택하면 빌드 설정 을 기반으로 생성해준다\n- Spring initialzr 를 통해 생성된 build.gralde.kts\n\n```gradle\nimport org.jetbrains.kotlin.gradle.tasks.KotlinCompile\n\nplugins { \n    id(\"org.springframework.boot\") version \"2.6.7\" \n    id(\"io.spring.dependency-management\") version \"1.0.11.RELEASE\" \n    kotlin(\"jvm\") version \"1.6.21\" \n    kotlin(\"plugin.spring\") version \"1.6.21\"\n}\n\ngroup = \"com.example\"\n\nversion = \"0.0.1-SNAPSHOT\"\n\njava.sourceCompatibility = JavaVersion.VERSION_11\n\nrepositories { \n    mavenCentral() \n}\n\ndependencies { \n    implementation(\"org.springframework.boot:spring-boot-starter\") \n    implementation(\"org.jetbrains.kotlin:kotlin-reflect\") \n    implementation(\"org.jetbrains.kotlin:kotlin-stdlib-jdk8\") \n    testImplementation(\"org.springframework.boot:spring-boot-starter-test\") \n}\n\ntasks.withType<KotlinCompile> { \nkotlinOptions { \n        freeCompilerArgs = listOf(\"-Xjsr305=strict\") jvmTarget = \"11\" \n    } \n}\n\ntasks.withType<Test> { \n    useJUnitPlatform() \n}\n```\n\n\n- 코틀린 스프링 프로젝트에서 필수적인 플러그인\n  - kotlin(\"plugin.spring\")\n\n- 코틀린 스프링 프로젝트에서 필수적인 의존성\n  - org.jetbrains.kotlin:kotlin-reflect\n  - org.jetbrains.kotlin:kotlin-stdlib\n\n이외에도 plugin.jpa, jackson-module-kotlin 등 프로젝트를 구성하면서 필요한 플러그인 과 <br/>\n코틀린 의존성이 있고 Springinitialzr에서 프로젝트를 구성할 경우 자동으로 세팅해준다\n\n# 스프링 부트\n```\n@SpringBootApplication class DemoApplication\n\n// fun 탑- 레벨 함수이므로 클래스 바깥에서{ 호출\nmain(args: Array<String>) {\n    runApplication<DemoApplication>(*args)\n}\n```\n\n### @ConfigurationProperties\n- 스프링 애플리케이션에 지정한 설정을 기반으로 설정 클래스를 만들때, <br/>\n  @ConstructorBinding 을 사용하면 setter가 아닌 생성자를 통해 바인딩 하므로 <br/>\n  불변 객체를 쉽게 생성할 수 있다.\n\n```kotlin\n@ConstructorBinding\n@ConfigurationProperties(\"example.kotlin\") \n\ndata class KotlinExampleProperties(\n                val name: String,\n                val description: String,\n                val myService: MyService\n                ) {\n\ndata class MyService(\n            val apiToken: String,\n            val uri: URI\n        )\n\n}\n```\n\n### 테스트 지원\n- 기본 제공되는 Junit5 기반의 테스트를 특별한 설정 없이 그대로 사용이 가능하다\n- 모의 객체를 만들어 테스트하려면 Mockito 대신 MockK를 사용할 수 있다"},{"excerpt":"문득 java 21 이 등장하면서 virtual Thread 가 hot 한 지금..  한물 간다는 webFlux 를 공부하는게 맞을까 ...? 아니다... 왜 사라지는지 확실하게 짚고 넘어가는 게 맞다... cpu Bound 와 IO Bound 에 대해서 알아보자 단순 cpu 를 쓴다 라고 끝나는게 아니라, 다수의 데이터에 대한 집계 혹은 암호화 등 cp…","fields":{"slug":"/cpu-bound-vs-io-bound/"},"frontmatter":{"date":"January 12, 2024","title":"CPU Bound 와 IO Bound","tags":["webFlux"]},"rawMarkdownBody":"\n# 문득 java 21 이 등장하면서 virtual Thread 가 hot 한 지금..\n![img.png](img.png)\n### 한물 간다는 webFlux 를 공부하는게 맞을까 ...?\n> 아니다... 왜 사라지는지 확실하게 짚고 넘어가는 게 맞다...\n\n### cpu Bound 와 IO Bound 에 대해서 알아보자\n- 단순 cpu 를 쓴다 라고 끝나는게 아니라, 다수의 데이터에 대한 집계 혹은 암호화 등 cpu 계산 능력에 따라 성능이 좌지우지 되는 능력을 말한다.\n\n### 아래 그림을 보자\n![img_1.png](img_1.png)\n\n위 그림을 보면 `application 영역`, `커널 영역`, `하드웨어 영역` 을 계층화 하여 추상화로 나타낸 그림이다. <br/> \n여기서 동시간에 하나의 명령어를 처리할 수 있는 CPU core 가 한개 있다고 가정해보자 <br/>\n\napplication 은 실행되는 프로세스라고 보면 된다. <br/>\n이때 물리적인 cpu core 에 명령을 내린다고 가정해보자 <br/>\n\n![img_2.png](img_2.png)\n\n그리고 어플리케이션이 N 개가 더 추가되어 단일 CPU 코어 1 에 각각의 작업을 동작시켰다고 가정해보자. <br/>\n\n![img_3.png](img_3.png)\n\n이떄 CPU 코어에서는 동시에 실행한 것처럼 보일수 있다 <br/>\n\n> 그럼 동시에 `병렬` 로 처리한걸까 ? \n\n![img_4.png](img_4.png)\n\n그렇지 않다. 동시간대 하나의 명령만 처리 할 수 있기 때문에, 타임 슬라이스를 아주 잘게 나눠서 잘라보면 <br/>\n실제로 어플리케이션 1 번과 2 ... N 번이 번갈아 가면서 실행하게 된다. <br/>\n\n이렇게 번갈아 가면서 실행하는 과정을 OS 에서는 Context Switching 이라고 한다.\n> 실행관점에서 문맥을 바꾸었다. 라는 의미다.\n\n이러한 컨텍스트 스위칭 (ContextSwitching) 작업들은 CPU Bound 어플리케이션 에서 성능 저하를 가져오게 되는데 <br/>\n\n그림으로 보면 아래와 같다.\n\n![img_5.png](img_5.png)\n\n어플리케이션이 실행되어 메모리에 로드되고 프로세스로 동작하게 될텐데. <br/>\nCPU 로 스케줄링 되어 실행될때, 기계어 실행을 위해 필요한 데이터들을 cpu Register 로 미리 가져오게 된다. <br/>\n\n그리고 ALU 를 통해 실제 계산을 진행하게 되는데 Register 에는 기존에 어떤 명령까지 진행했는지를 함께 저장 해 놓고 <br/>\n필요에 의해 캐시를 해놓기 때문에, 동일한 프로세스의 일을 꾸준히 하면 할 수록 성능적으로 더 효과 적이다.\n\n![img_6.png](img_6.png)\n\n컨텍스트 스위칭은 위 그림과 같이 어플리케이션 2번을 실행시키기 위해 Register 정보를 초기화 하는 과정부터 시작한다. <br/>\n정확히는 어플리케이션 1 번이 실행했던 기존 실행 정보들을 메모리에 별도 저장 해 놓고, 2 번 어플리케이션 데이터 정보를 가져와서 다시 Register 적재를 한 뒤 명령어들을 실행하게 된다. <br/>\n하나의 CPU 에서 다수의 프로세스들이 번갈아 가면서 cpu 작업들을 진행해야 하기 때문에 성능상 오버헤드가 발생한다고 할 수 있다. <br/>\n\n### 그럼 여기서 문제...\n![img_7.png](img_7.png)\n\n위 어플리케이션 들을 어떻게 실행시키는게 가장 빠를까 \n> 하나씩 순차적으로 실행하는게 가장 빠르다 ( 너무 당연한가 ? ) <br/>\n> 컨텍스트 스위칭 이라는 오버헤드가 있기 때문 <br/>\n\n### 어떻게 하면 CPU Bound 상황을 효과적으로 만질 수 있을까 ?\n![img_8.png](img_8.png)\n\n흔히 말할 수 있는 정략은 위와 같이 병렬 처리 되어야 효과적이다. <br/>\n동 시간대 각각의 명령어를 동 시간대에 처리할 수 있기 때문이다. <br/>\n\n## I/O Bound 란\n입출력 장치의 중점적인 작업들을 말한다. <br/>\n대표적인 작업들은 키보드와 같은 사용자 입력, 디스크 파일 복사, 네트워크를 통한 데이터를 주고받는 행위들을 모두 I/O 작업이라고 한다.\n![img_9.png](img_9.png)\n\n위 그림과 같이 client 와 server 는 연결이 되어있는 상태이고, Hello 라는 문자열을 네트워크를 통해 전송한다고 가정해보자. <br/>\n\n![img_10.png](img_10.png)\n\nNIC ( Network Interface Card ) 장치 는 네트워크 패킷을 주고 받는 역할을 맡고 있다. <br/>\nClient 가 전달한 Hello 패킷을 Nic 장치를 통해 전달받고, 커널에서 네트워크 프로토콜을 진행하게 되는데 <br/> \n서버 application 입장에선, Kerner 에서 패킷을 전달받기 전까지 ```대기``` 를 하게 된다. <br/>\nNic 장치 로 부터 패킷을 받고 커널 까지의 과정 또한 CPU 사용이 필요한 영역이긴 한데, <br/>\napplication 관점에서는 패킷을 수신 완료까지 를 대기하기 때문에, CPU 를 중점적으로 사용하지 않는 상태라고 볼 수 있다. <br/>\n만약 패킷이 오지 않았다 라고 가정한다면, 해당 서버의 프로세스는 계속해서 대기를 하게 되는것이다. <br/>\n\n## Web Application 서버 관점에서 어떠한 I/O 들이 있을까\n![img_11.png](img_11.png)\n\n그림으로 보면 클라이언트로 부터 전달 받는 http 프로토콜을 처리하는것도 web Application 에서는 network I/O 이고, <br/> \nWeb Application 에서 비즈니스 로직 이후 DB 에 쿼리하는 영역도 I/O 이다. <br/>\n또한 DB 시스템에서 데이터를 조회하고, 삭제하고, 저장하는것도 I/O 라고 볼 수 있고, <br/>\nWeb Application 에서 외부 API 서버 요청 에 대한 것도 네트워크 I/O 가 발생하게 된다 <br/>\n\n> 하나의 웹 서비스 에서도 I/O 작업이 여기저기 산재되어 있는데, 반드시 인지하고 있어야 할 개념이다.\n\n## 만약 클라이언트로 부터 많은 요청이 들어오게 된다면, 어떻게 해야할까\n전통적인 해결 방법은 webApplication Thread 갯수를 늘리는 것이다.\n![img_13.png](img_13.png)\n\nThread Per Request 혹은 Thread for Connection 이러고도 하는데, 이는 <br/>\n하나의 요청에 하나의 Thread 가 필요하다는 의미이다. <br/>\n\n예를들어 굉장히 많은 Thread 가 실행된다고 가정한다면, <br/>\n성능 관점에서 CPU 컨텍스트 스위칭을 고려해야 하는데, 이런 컨텍스트 스위칭 오버헤드를 감수하더라도 I/O 요청을 최대한 처리할 수 있도록 하는 전략이라고 볼 수 있다. <br/>\n\n만약에 하나에 Thread 가 하나의 연결을 처리하고 있는 순간 다른 추가 요청이 있게 되면, <br/>\n대기를 하는게 아니라 또다른 Thread 를 처리하게 된다. <br/>\n\n만약 대량의 요청을 처리하기 위해 요청 수 만큼 Thread 갯수를 늘리게 되면 결국 OOM 이 나버리게 된다.<br/>\n만약 10만의 요청을 동시처리하고 싶다고 가정한다면, `(10 만 * 스레드 크기 )` == `메모리 용량` 이 되버린다.<br/>\n거기에 하드웨어 최대 메모리까지 사용하게 되면 시스템이 아예 동작하지 못할수도 있다.<br/>\n\n커널에는 OOM 이라는 안전장치가 존재한다. ( 주요 프로세스를 Kill 해서 시스템 다운을 예방하는 역할 )<br/>\n\n반면 사용이 완료된 Thread 를 삭제하는것도 문제다. <br/>\n새로 들어오는 요청에 의해 다시 만들어야 되니까 ..<br/>\n결국 쓰레드를 관리해야 하는것이 성능 관점에서 손해이다. <br/>\n\n이떄문에 Thread Pool 이 해결 방안으로 볼 수 있겠다. <br/>\n\n> 가용 가능한 다수의 쓰레드를 미리 만들어 놓고, <br/>\n> 요청이 들어오면 미리 만들어 놓은 쓰레드를 활용하고 사용이 다 했으면 해당 쓰레드를 다시 쓰레드 풀 에 반납하는 전략을 말한다. <br/>\n\n\n\n"},{"excerpt":"배포 전략","fields":{"slug":"/deploy-strategy/"},"frontmatter":{"date":"November 18, 2022","title":"배포전략","tags":["배포"]},"rawMarkdownBody":"\n# 배포 전략\n"}]}},"pageContext":{}},"staticQueryHashes":[],"slicesMap":{}}