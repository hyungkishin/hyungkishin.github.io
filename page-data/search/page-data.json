{"componentChunkName":"component---src-pages-search-jsx","path":"/search/","result":{"data":{"allMarkdownRemark":{"nodes":[{"excerpt":"Redis 에 대해서 개념 :) Remote Dictionary Storage 의 약자로 'Redis' 라고 불리운다.  Redis 는 memory 기반의 data 저장소 이다. 메모리에 데이터를 저장하다보니, 빠르다. 단, 휘발성이다. Single Thread - CPU 를 하나만 사용한다. 초당 5 만에서 25만 Request 실행 가능하다. Key-…","fields":{"slug":"/redis/"},"frontmatter":{"date":"April 02, 2024","title":"Redis","tags":["Redis"]},"rawMarkdownBody":"\n# Redis 에 대해서\n\n## 개념 :)\n- Remote Dictionary Storage 의 약자로 'Redis' 라고 불리운다. \n- Redis 는 memory 기반의 data 저장소 이다.\n  - 메모리에 데이터를 저장하다보니, 빠르다.\n  - 단, 휘발성이다.\n- Single Thread - CPU 를 하나만 사용한다.\n- 초당 5 만에서 25만 Request 실행 가능하다.\n- Key-Value 형식으로 데이터를 저장한다.\n\n## 장점 : Read/Write 속도\n- Hardware (I/O) 차이에서 오는 기본적인 performance gap 이 좀 있다.\n- 다양한 Type 의 아키텍쳐를 지원한다. (Single, Master-Slave, Sentinel, Cluster)\n- Partitioning\n  - 데이터 저장시 여러노드에 분산되어 저장된다\n- Popular\n  - 인기가 많으니 지원하는 라이브러리가 다양하다.\n  - 방대한 커뮤니티.\n\n## 단점 : 휘발성\n- AOF, RDB Snapshot 을 통해 Disk 에 저장하여 휘발성 문제를 해소\n- Single Thread\n- Memory Fragmentation\n  - Fragmentation 이란 : 메모리에 썼다 지웠다 를 반복하다보면 실제로 데이터가 존재하지 않아도 해당 메모리에 데이터가 존재한다고 인식하는 경우, 혹은 그 반대인 경우도 있다.\n    - 주기적으로 Fragmentation 을 지워주는것이 좋다.\n- Big Size Data 에 적합하지 않다.\n  - 휘발성 이라는 문제를 해소하기 위해서 Disk 에서 memory 에 있는 데이터를 읽거나, 변경된 부분에 대해서 Disk 에 쓰게 되는데.\n  - 데이터가 너무 많이 들어가 있게 되면 Disk 에 쓰는 시간이 오래걸리게 된다\n    - 오래 걸리면 Replication 이랑 Sync 가 안맞는 문제가 생길수도 있다.\n    - 해당 요청으로 다른 요청이 대기를 하고 있는 상황이 벌어질 수 있다.\n    - 디스크에 쓰는 양을 줄이기 위해서 다양한 옵션들을 설정하기도 하지만 기본적으로 너무 많은 데이터를 넣은 것은 (일반적으로) 적합하지 않다.\n\n## 목적 : Cashing\n![img.png](img.png)\n> 자주 (사용되고, 반복되고) 빠르게 응답해야 되는것들 을 미리 준비해 두는것.\n\n## 일반적 사용 : Session Store, List Data Caching\n- List 형태의 데이터의 경우 일반 SQL 서버보다 약 10 배 이상의 성능을 낸다고 알려져있다.\n\n"},{"excerpt":"문득 java 21 이 등장하면서 virtual Thread 가 hot 한 지금..  한물 간다는 webFlux 를 공부하는게 맞을까 ...? 아니다... 왜 사라지는지 확실하게 짚고 넘어가는 게 맞다... cpu Bound 와 IO Bound 에 대해서 알아보자 단순 cpu 를 쓴다 라고 끝나는게 아니라, 다수의 데이터에 대한 집계 혹은 암호화 등 cp…","fields":{"slug":"/cpu-bound-vs-io-bound/"},"frontmatter":{"date":"January 12, 2024","title":"CPU Bound 와 IO Bound","tags":["webFlux"]},"rawMarkdownBody":"\n# 문득 java 21 이 등장하면서 virtual Thread 가 hot 한 지금..\n![img.png](img.png)\n### 한물 간다는 webFlux 를 공부하는게 맞을까 ...?\n> 아니다... 왜 사라지는지 확실하게 짚고 넘어가는 게 맞다...\n\n### cpu Bound 와 IO Bound 에 대해서 알아보자\n- 단순 cpu 를 쓴다 라고 끝나는게 아니라, 다수의 데이터에 대한 집계 혹은 암호화 등 cpu 계산 능력에 따라 성능이 좌지우지 되는 능력을 말한다.\n\n### 아래 그림을 보자\n![img_1.png](img_1.png)\n\n위 그림을 보면 `application 영역`, `커널 영역`, `하드웨어 영역` 을 계층화 하여 추상화로 나타낸 그림이다. <br/> \n여기서 동시간에 하나의 명령어를 처리할 수 있는 CPU core 가 한개 있다고 가정해보자 <br/>\n\napplication 은 실행되는 프로세스라고 보면 된다. <br/>\n이때 물리적인 cpu core 에 명령을 내린다고 가정해보자 <br/>\n\n![img_2.png](img_2.png)\n\n그리고 어플리케이션이 N 개가 더 추가되어 단일 CPU 코어 1 에 각각의 작업을 동작시켰다고 가정해보자. <br/>\n\n![img_3.png](img_3.png)\n\n이떄 CPU 코어에서는 동시에 실행한 것처럼 보일수 있다 <br/>\n\n> 그럼 동시에 `병렬` 로 처리한걸까 ? \n\n![img_4.png](img_4.png)\n\n그렇지 않다. 동시간대 하나의 명령만 처리 할 수 있기 때문에, 타임 슬라이스를 아주 잘게 나눠서 잘라보면 <br/>\n실제로 어플리케이션 1 번과 2 ... N 번이 번갈아 가면서 실행하게 된다. <br/>\n\n이렇게 번갈아 가면서 실행하는 과정을 OS 에서는 Context Switching 이라고 한다.\n> 실행관점에서 문맥을 바꾸었다. 라는 의미다.\n\n이러한 컨텍스트 스위칭 (ContextSwitching) 작업들은 CPU Bound 어플리케이션 에서 성능 저하를 가져오게 되는데 <br/>\n\n그림으로 보면 아래와 같다.\n\n![img_5.png](img_5.png)\n\n어플리케이션이 실행되어 메모리에 로드되고 프로세스로 동작하게 될텐데. <br/>\nCPU 로 스케줄링 되어 실행될때, 기계어 실행을 위해 필요한 데이터들을 cpu Register 로 미리 가져오게 된다. <br/>\n\n그리고 ALU 를 통해 실제 계산을 진행하게 되는데 Register 에는 기존에 어떤 명령까지 진행했는지를 함께 저장 해 놓고 <br/>\n필요에 의해 캐시를 해놓기 때문에, 동일한 프로세스의 일을 꾸준히 하면 할 수록 성능적으로 더 효과 적이다.\n\n![img_6.png](img_6.png)\n\n컨텍스트 스위칭은 위 그림과 같이 어플리케이션 2번을 실행시키기 위해 Register 정보를 초기화 하는 과정부터 시작한다. <br/>\n정확히는 어플리케이션 1 번이 실행했던 기존 실행 정보들을 메모리에 별도 저장 해 놓고, 2 번 어플리케이션 데이터 정보를 가져와서 다시 Register 적재를 한 뒤 명령어들을 실행하게 된다. <br/>\n하나의 CPU 에서 다수의 프로세스들이 번갈아 가면서 cpu 작업들을 진행해야 하기 때문에 성능상 오버헤드가 발생한다고 할 수 있다. <br/>\n\n### 그럼 여기서 문제...\n![img_7.png](img_7.png)\n\n위 어플리케이션 들을 어떻게 실행시키는게 가장 빠를까 \n> 하나씩 순차적으로 실행하는게 가장 빠르다 ( 너무 당연한가 ? ) <br/>\n> 컨텍스트 스위칭 이라는 오버헤드가 있기 때문 <br/>\n\n### 어떻게 하면 CPU Bound 상황을 효과적으로 만질 수 있을까 ?\n![img_8.png](img_8.png)\n\n흔히 말할 수 있는 정략은 위와 같이 병렬 처리 되어야 효과적이다. <br/>\n동 시간대 각각의 명령어를 동 시간대에 처리할 수 있기 때문이다. <br/>\n\n## I/O Bound 란\n입출력 장치의 중점적인 작업들을 말한다. <br/>\n대표적인 작업들은 키보드와 같은 사용자 입력, 디스크 파일 복사, 네트워크를 통한 데이터를 주고받는 행위들을 모두 I/O 작업이라고 한다.\n![img_9.png](img_9.png)\n\n위 그림과 같이 client 와 server 는 연결이 되어있는 상태이고, Hello 라는 문자열을 네트워크를 통해 전송한다고 가정해보자. <br/>\n\n![img_10.png](img_10.png)\n\nNIC ( Network Interface Card ) 장치 는 네트워크 패킷을 주고 받는 역할을 맡고 있다. <br/>\nClient 가 전달한 Hello 패킷을 Nic 장치를 통해 전달받고, 커널에서 네트워크 프로토콜을 진행하게 되는데 <br/> \n서버 application 입장에선, Kerner 에서 패킷을 전달받기 전까지 ```대기``` 를 하게 된다. <br/>\nNic 장치 로 부터 패킷을 받고 커널 까지의 과정 또한 CPU 사용이 필요한 영역이긴 한데, <br/>\napplication 관점에서는 패킷을 수신 완료까지 를 대기하기 때문에, CPU 를 중점적으로 사용하지 않는 상태라고 볼 수 있다. <br/>\n만약 패킷이 오지 않았다 라고 가정한다면, 해당 서버의 프로세스는 계속해서 대기를 하게 되는것이다. <br/>\n\n## Web Application 서버 관점에서 어떠한 I/O 들이 있을까\n![img_11.png](img_11.png)\n\n그림으로 보면 클라이언트로 부터 전달 받는 http 프로토콜을 처리하는것도 web Application 에서는 network I/O 이고, <br/> \nWeb Application 에서 비즈니스 로직 이후 DB 에 쿼리하는 영역도 I/O 이다. <br/>\n또한 DB 시스템에서 데이터를 조회하고, 삭제하고, 저장하는것도 I/O 라고 볼 수 있고, <br/>\nWeb Application 에서 외부 API 서버 요청 에 대한 것도 네트워크 I/O 가 발생하게 된다 <br/>\n\n> 하나의 웹 서비스 에서도 I/O 작업이 여기저기 산재되어 있는데, 반드시 인지하고 있어야 할 개념이다.\n\n## 만약 클라이언트로 부터 많은 요청이 들어오게 된다면, 어떻게 해야할까\n전통적인 해결 방법은 webApplication Thread 갯수를 늘리는 것이다.\n![img_13.png](img_13.png)\n\nThread Per Request 혹은 Thread for Connection 이러고도 하는데, 이는 <br/>\n하나의 요청에 하나의 Thread 가 필요하다는 의미이다. <br/>\n\n예를들어 굉장히 많은 Thread 가 실행된다고 가정한다면, <br/>\n성능 관점에서 CPU 컨텍스트 스위칭을 고려해야 하는데, 이런 컨텍스트 스위칭 오버헤드를 감수하더라도 I/O 요청을 최대한 처리할 수 있도록 하는 전략이라고 볼 수 있다. <br/>\n\n만약에 하나에 Thread 가 하나의 연결을 처리하고 있는 순간 다른 추가 요청이 있게 되면, <br/>\n대기를 하는게 아니라 또다른 Thread 를 처리하게 된다. <br/>\n\n만약 대량의 요청을 처리하기 위해 요청 수 만큼 Thread 갯수를 늘리게 되면 결국 OOM 이 나버리게 된다.<br/>\n만약 10만의 요청을 동시처리하고 싶다고 가정한다면, `(10 만 * 스레드 크기 )` == `메모리 용량` 이 되버린다.<br/>\n거기에 하드웨어 최대 메모리까지 사용하게 되면 시스템이 아예 동작하지 못할수도 있다.<br/>\n\n커널에는 OOM 이라는 안전장치가 존재한다. ( 주요 프로세스를 Kill 해서 시스템 다운을 예방하는 역할 )<br/>\n\n반면 사용이 완료된 Thread 를 삭제하는것도 문제다. <br/>\n새로 들어오는 요청에 의해 다시 만들어야 되니까 ..<br/>\n결국 쓰레드를 관리해야 하는것이 성능 관점에서 손해이다. <br/>\n\n이떄문에 Thread Pool 이 해결 방안으로 볼 수 있겠다. <br/>\n\n> 가용 가능한 다수의 쓰레드를 미리 만들어 놓고, <br/>\n> 요청이 들어오면 미리 만들어 놓은 쓰레드를 활용하고 사용이 다 했으면 해당 쓰레드를 다시 쓰레드 풀 에 반납하는 전략을 말한다. <br/>\n\n\n\n"},{"excerpt":"코들린의 현재와 미래 코틀린을 배워야하는 이유 코틀린은 IntelliJ로 유명한 젯브레인사에서 만든 언어이기 때문에 IntelliJ에서 자동완성, 자 바-코틀린 변환, 코루틴 등 코틀린 관련 편의 기능을 완벽하게 지원 자바는 발표된지 20년이 넘었지만 코틀린, C#, 스위프트와 같은 현대적 언어에 비해 기능 이 부족함 자바에서 Best-Practice로 …","fields":{"slug":"/kotlin/"},"frontmatter":{"date":"January 12, 2024","title":"코틀린의 현재와 미래","tags":["코틀린"]},"rawMarkdownBody":"\n# 코들린의 현재와 미래\n### 코틀린을 배워야하는 이유\n- 코틀린은 IntelliJ로 유명한 젯브레인사에서 만든 언어이기 때문에 IntelliJ에서 자동완성, 자 바-코틀린 변환, 코루틴 등 코틀린 관련 편의 기능을 완벽하게 지원\n- 자바는 발표된지 20년이 넘었지만 코틀린, C#, 스위프트와 같은 현대적 언어에 비해 기능 이 부족함\n- 자바에서 Best-Practice로 불리는 기법들을 언어적 차원에서 기본 제공\n- 자바에 비해 문법이 간결하기 때문에 가독성과 생산성이 높고 오류 가능성이 적어진다\n\n```kotlin\ndata class Person(\n        val name: String, \n        val age: Int, \n        val email: String\n) // equals(), hashCode(), toString() 등 유용한 함수를 자동 생성\n\nobject MyCompany { // 싱글턴 객체 \n    const val name: String = \"MyCompany\"\n}\n\n// 탑- 레벨 함수로 클래스 외부에서 함수 작성 가능\nfun main() {\n    // `new` 키워드 없이 객체 생성\n    val person = Person(\"이상훈 \", 35, \" digimon1740 @gmail.com \")\n}\n```\n\n### 좀더 파해쳐 보자\n- 문법 간결\n- data class 라는 기능을 사용하게 되면\n  - 자동으로 equals, hashcode, toString 을 자동으로 생성함\n- object 라는 키워드를 사용하게되면\n  - 간단하게 싱글턴 객체를 만들어준다.\n- 함수를 탑 레벨에 위치\n  - 탑 레벨 함수는 클래스 외부에서 함수를 작성할 수 있는 기능이다. ( 별도의 클래스 없이 작성가능 )\n  - 반면 자바에서는 기본적으로 클래스를 만들고 그 안에서 메서드를 만든다.\n- new 키워드 없이 객체를 만들 수 있다.\n- 멀티 플랫폼 언어이다\n  - 서버개발\n  - e.g ) 모바일 앱, 프론트 js, 안드로이드\n\n### 기업의 개선점\n- google 의 경우 npe 를 33% 절감 함\n- 그로인해 사용자 환경은 크게 향상 시켰다.\n\n### 코틀린 타임라인\n- 2016년 2월 코틀린 1.0 릴리즈\n- 2017년 1월 스프링 프레임워크 5.0 부터 코틀린 공식 지원 발표\n- 2017년 5월 구글 IO 에서 안드로이드 공식 지원 언어로 발표\n- 2019년 5월 구글 IO 에서 안드로이드 개발시 최우선 언어 (Kotlin-First) 발표\n- 2022년 5월 코틀린 1.7 베타 릴리즈\n- ...\n\n# 자바에는 있는데 코틀린엔 없는기능\n### 체크드 익셉션(Checked Exception)\n- 자바의 익셉션 계층\n- Throwable : 예외 계층의 최상위 클래스\n- Error : 시스템에 비정상적인 상황이 발생 예측이 어렵고 기본적으로 복구가 불가능 함\n  - e.g) OutOfMemoryError, StackOverflowError, etc\n- Exception : 시스템에서 포착 가능하여 etc (try-catch) 복구 가능\n  - 예외 처리 강제 IOException, FileNotFoundException,\n  - @Transactional 에서 해당 예외가 발생하면 기본적으론 롤백이 동작하지 않음\n    - rollbackFor: 를 사용해야함\n- RuntimeException\n  - 런타임시에 발생하는 예외 예외 처리를 강제하지 않음\n  - e.g ) NullPointerException, ArrayIndexOutOfBoundsException, etc\n\n![img.png](img.png)\n\n- java 에서 체크드 익셉션은 무조건 try catch 로 감싸줘야 하거나 throw 라는 키워드로 예외를 전파하지 않으면 컴파일 에러가 발생.\n```java\ntry {\n    Thread.slepp(1);\n} catch (InterrupedException e) {\n    // 예외처리    \n}\n```\n- kotlin 에서는 체크드 익셉션을 강제 하지 않는다.\n  - 그러나 원한다면 가능하다.\n  - 자바에서 의미없는 체크드 exception 을 지양하는듯해.\n\n### 기본 자료형\n- 자바는 원시 자료형을 지원하며 객체로된 레퍼런스 타입도 지원한다.\n```java\nint i = 0;\nInteger ii = 0;\nString str = ii.toString();\n```\n- 코틀린은 레퍼런스 타입만 지원한다.\n```kotlin\nval i: Int = 0;\nval str: String = i.toString();\n```\n\n- 코틀린의 레퍼런스 타입은 최적화된 방식으로 컴파일 한다.\n```kotlin\nint i = 0;\nString str = String.valueOf(i);\n```\n\n--\n### 정적멤버\n- 자바는 static 키워드로 정적멤버를 선언한다.\n```java\npublic class JavaClass {\n    static int i = 0;\n    \n    public static void staticMethod() {\n        // ...\n    }\n}\n```\n- 코틀린은 companion object 로 대체\n```kotlin\nclass KotlinClass {\n    companion object {\n        val i: Int = 0;\n        fun function() {\n            // ...\n        }\n    }\n}\n```\n\n### 3항 연산자\n- 자바\n```java\nString animalSound = \"호랑이\".equals(animal) ? \"어흥\" : \"야홍\";\n```\n- 코틀린은 if else 로 대체한다.\n```kotlin\nval animalSound: String = if (\"호랑이\" == animal) \"어흥\" : \"야홍\";\n```\n--\n\n### 세미콜론\n- 자바는 무조건 ; 세미콜론이 붙지만 코틀린은 안붙는다.\n```java\nBoolean isAdmin = userService.isAdmin(userId);\n```\n\n```kotlin\nval isAdmin: Boolean = userService.isAdmin(userId)\n```\n\n# 코틀린에는 있는데 자바에는 없는기능\n### 확장\n- 개발자가 임의로 객체의 함수나 프로퍼티를 확장해서 사용할 수 있다.\n\n```kotlin\nfun String.first(): Char {\n    return this[0]\n}\n\nfun String.addFirst(char: Char): String {\n    return char + this.substring(0)\n}\n\nfun main() {\n    println(\"ABCD\".first()) // 출력 A\n    println(\"ABCD\".addFirst('Z')) // 출력 ZABCD \n}\n```\n\n### 데이터 클래스\n- 데이터를 보관하거나 전달하는 목적을 가진 불변 객체로 사용\n\n```kotlin\ndata class Person(val name: String, val age: Int) {\n    // hashCode(), equals(), toString() 자동생성됨\n    // 이외에도 copy(), componentN 도 유용함.\n}\n```\n\n- 기존 자바에선 주로 lombok 을 사용\n\n```java\n@Getter\npublic class Person {\n    private final String name;\n    private final int age;\n}\n```\n\n```kotlin\n// jdk 15 에선 record 라는 이름이 추가됨\npublic record Person(String name, int age) {\n    \n}\n```\n--\n\n# 문자열 템플릿\n- 문자열에 변수를 사용하거나 여러행으로 된 텍스트 블록을 사용 할 수 있다.\n```kotlin\nval text = \"World\"\nval greeting = \"Hello, ${text}\"\n\nprintln(greeting) // Hello, World\n\n//  문자열 템플릿 기반의 다이나믹 쿼리\nfun sql(nameIncluded: Boolean) =\n        \"\"\"\n          SELECT id, name, email, age \n          FROM users \n          WHERE id = :id ${\n                if (nameIncluded) {\n                  \"\"\"\n                  AND name = :name\n                  \"\"\" \n                } else \"\"\n            }\n        \"\"\"\n```\n\n### 기타\n- 스마트 캐스트 실드 클래스 (Jdk15 추가)\n- 위임\n- 중위 표현식\n- 연산자 오버로딩\n- 코루틴\n- etc\n\n\n# 공식문서\n- https://docs.spring.io/spring-framework/reference/web/webmvc/mvc-servlet.html\n- 공식 문서의 샘플 코드를 보면 kotlin 탭을 제공\n\n![img_1.png](img_1.png)\n\n# Spring initializr\n- 기본 언어로 코틀린을 선택할 수 있고 코틀린인 경우 Gradle Project를 선택하면 빌드 설정 을 기반으로 생성해준다\n- Spring initialzr 를 통해 생성된 build.gralde.kts\n\n```gradle\nimport org.jetbrains.kotlin.gradle.tasks.KotlinCompile\n\nplugins { \n    id(\"org.springframework.boot\") version \"2.6.7\" \n    id(\"io.spring.dependency-management\") version \"1.0.11.RELEASE\" \n    kotlin(\"jvm\") version \"1.6.21\" \n    kotlin(\"plugin.spring\") version \"1.6.21\"\n}\n\ngroup = \"com.example\"\n\nversion = \"0.0.1-SNAPSHOT\"\n\njava.sourceCompatibility = JavaVersion.VERSION_11\n\nrepositories { \n    mavenCentral() \n}\n\ndependencies { \n    implementation(\"org.springframework.boot:spring-boot-starter\") \n    implementation(\"org.jetbrains.kotlin:kotlin-reflect\") \n    implementation(\"org.jetbrains.kotlin:kotlin-stdlib-jdk8\") \n    testImplementation(\"org.springframework.boot:spring-boot-starter-test\") \n}\n\ntasks.withType<KotlinCompile> { \nkotlinOptions { \n        freeCompilerArgs = listOf(\"-Xjsr305=strict\") jvmTarget = \"11\" \n    } \n}\n\ntasks.withType<Test> { \n    useJUnitPlatform() \n}\n```\n\n\n- 코틀린 스프링 프로젝트에서 필수적인 플러그인\n  - kotlin(\"plugin.spring\")\n\n- 코틀린 스프링 프로젝트에서 필수적인 의존성\n  - org.jetbrains.kotlin:kotlin-reflect\n  - org.jetbrains.kotlin:kotlin-stdlib\n\n이외에도 plugin.jpa, jackson-module-kotlin 등 프로젝트를 구성하면서 필요한 플러그인 과 <br/>\n코틀린 의존성이 있고 Springinitialzr에서 프로젝트를 구성할 경우 자동으로 세팅해준다\n\n# 스프링 부트\n```\n@SpringBootApplication class DemoApplication\n\n// fun 탑- 레벨 함수이므로 클래스 바깥에서{ 호출\nmain(args: Array<String>) {\n    runApplication<DemoApplication>(*args)\n}\n```\n\n### @ConfigurationProperties\n- 스프링 애플리케이션에 지정한 설정을 기반으로 설정 클래스를 만들때, <br/>\n  @ConstructorBinding 을 사용하면 setter가 아닌 생성자를 통해 바인딩 하므로 <br/>\n  불변 객체를 쉽게 생성할 수 있다.\n\n```kotlin\n@ConstructorBinding\n@ConfigurationProperties(\"example.kotlin\") \n\ndata class KotlinExampleProperties(\n                val name: String,\n                val description: String,\n                val myService: MyService\n                ) {\n\ndata class MyService(\n            val apiToken: String,\n            val uri: URI\n        )\n\n}\n```\n\n### 테스트 지원\n- 기본 제공되는 Junit5 기반의 테스트를 특별한 설정 없이 그대로 사용이 가능하다\n- 모의 객체를 만들어 테스트하려면 Mockito 대신 MockK를 사용할 수 있다"},{"excerpt":"배포 전략에 관하여 문득 dev 환경에서 테스트를 할겸 \n열씸히 dev 브렌치를 merge 후 열씸히 젠킨스 빌드버튼을 누르던 중  배포 전략에 대한 내용을 생각해보게 되었습니다.  배포 전략 ? 모놀리틱 서비스 환경에서 마이크로 서비스 환경으로 바뀌면서 배포 주기가 짧아졌기 때문에 \n배포 전략이 필요하게 되었답니다.  중단 배포 방식, 다운타임 (Dow…","fields":{"slug":"/deploy-strategy/"},"frontmatter":{"date":"November 18, 2022","title":"배포전략","tags":["배포"]},"rawMarkdownBody":"\n# 배포 전략에 관하여\n\n문득 dev 환경에서 테스트를 할겸 <br/>\n열씸히 dev 브렌치를 merge 후 열씸히 젠킨스 빌드버튼을 누르던 중\n\n![](click.gif)\n\n배포 전략에 대한 내용을 생각해보게 되었습니다. <br/>\n\n# 배포 전략 ?\n모놀리틱 서비스 환경에서 마이크로 서비스 환경으로 바뀌면서 배포 주기가 짧아졌기 때문에 <br/>\n배포 전략이 필요하게 되었답니다. <br/>\n\n# 중단 배포 방식, 다운타임 (DownTime)\n\n중단 배포 방식은 배포 중에 서비스가 중단되는 방식입니다. <br/>\n사용자들은 자연스레 서비스가 중단되는 시간동안 서비스를 이용할 수 없게 되겠습니다. <br/>\n서비스를 사용할 수 없는 시간대를 downtime 이라고 합니다. <br/>\n때문에 현대에 웹 어플리케이션 에서 중단 배포 방식은 자연스레 사용하지 않게 되었습니다. <br/>\n그래서 등장한 전략이 \" 무중단 배포 \" 전략입니다.\n\n# 무중단 배포 전략의 종류 로는 크게 세가지가 있습니다.\n- Rolling 배포\n- Blue/Green 배포\n- Canary 배포\n\n각각의 전략에 따라 장단 점이 극명한데 <br/>\n주관적인 생각으로는 서비스의 특성에 따라 적절한 전략을 선택하는 것이 좋을 것 같습니다. <br/>\n\n## Rolling 배포\n\n사실 여러 블로그, 문서들을 찾아보면서 배포 전략에 대한 내용을 찾아보았는데 <br/>\n그림이 마땅치가 않습니다... <br/>\n제일 널리 알려져 있는 그림은 아래와 같으나, 제가 본 최고의 그림은 저작권이 있어서 아래 그림으로 대체하겠습니다. <br/>\n100 만의 트레픽을 받는 인스턴스가 총 3대가 띄워져 있다고 가정하겠습니다 :) <br/>\n\n\n3 대중 2대만이 운영 트레픽을 받게되고 1대는 LB (로드벨런서) 에서 떼어놓습니다. <br/>\n그렇게 2대만이 가용서버가 되고 트레픽은 각각 50만 50만 씩 사이좋게 나누어 받습니다. <br/>\n배포가 완료되고 다음차례인 서버에 배포를 진행합니다. <br/>\n이과정에서 로드벨런서 를 붙였다 뗏다를 반복하며, 순차적으로 모든 서버가 신규 서버로 점진적 교체가 이루어 지면서 배포가 완료됩니다. <br/>\n(물론 이때 트레픽은 100% 운영중인 서버에만 흘러가게 됩니다.) <br/>\n\n이것이 Rolling 배포방식이 되겠습니다 :) <br/>\n\n## 장점\n- 서비스 자원을 그대로 이용하기 때문에 낭비가 없습니다.\n- 배포를 차례로 진행하기 때문에 상황에 따라 손쉽게 롤백이 가능하다는 점.\n\n## 단점\n- 구 버전과 신 버전이 공존하며, 호환성 문제가 발생할 수 있다는점.\n- 트레픽이 몰리다보니 도메인에 따라, 사용자들이 덜 몰리는 새벽작업이 필연적일 수 있다는점.\n\n## Blue/Green 배포\n\n역시 총 3대의 인스턴스가 띄워져 있다고 가정하겠습니다. <strike>그림에서 서버가 3개 라 가정함... </strike>  <br/>\n\n구버전이 배포되어 있는 인스턴스를 Blue, 신버전이 배포되어 있는 인스턴스를 Green 이라고 합니다. <br/>\n색깔에 많은 의의를 두지 않아도 됩니다 :) <br/>\n\n아무 의미가 없지만 레드 옐로 배포가 아닌 이유는, 우리가 보통 신호들에서 빨간불엔 안건ㄴ...<br/>\n\n아래 그림과 같이 구버전과 운영중인 블루 서버가 있고, <br/>\n신버전과 배포중인 그린 서버가 있습니다. <br/>\n\n그린 서버가 배포가 완료되면, 블루 서버와 그린 서버의 역할을 바꿔줍니다. <br/>\n그렇기 때문에 한번에 배포가 가능해 지겠죠 :)\n\n## 장점\n- Rolling 배포와 다르게 구버전과 신버전이 공존하지 않기 때문에 호환성 문제가 발생하지 않습니다.\n- 한번에 배포가 가능하기 때문에 트레픽이 몰리는 새벽작업이 필요없습니다.\n\n## 단점\n- 운영 서버가 운영되고 있는 서비스 자원이 두배로 들게 됩니다.\n\n## Canary 배포\n카나리 배포는 조금 슬픈 이야기가 존재합니다. <br/>\n19세기만 해도 탄광에서 가스 중독 사고가 많았답니다. <br/>\n광부들에게 희망을 준 것은 카나리아 라는 새였습니다. <br/>\n\n이 새는 일산화탄소와 메탄에 유독 약하기 때문에 광부들은 카나리아를 새장에 넣어 갱도로 들어가서 <br/>\n석탄을 캐다가 카나리아가 이상증세를 보이면 즉시 탈출했다. (아차 싶을땐 역시 도망이 최고) <br/>\n\"이상 증세가 보이면 바로 롤백 이 핵심\" <br/>\n\n카나리 배포는 아래 그림과 같이 소규모 유저들에게 신버전을 배포하고, <br/>\n이상증세가 보이면 바로 롤백을 진행하는 전략입니다. <br/>\n\n그러나 이런 전략 덕분에 A/B 테스트가 가능해 지겠네요 :) <br/>\n물론 점진적으로 신버전을 확장하다가 뒤늦게 이상증세를 확인하여 롤백하게 되는날엔 마음이 아프겠지만요 :) <br/>\n\n## 장점\n- 단계적인 전환 방식을 통해 부정적 영향을 최소화하고 상황에 따라 트래픽 양을 늘리거나 롤백할 수 있다.\n- A/B 테스트가 가능하다.\n\n## 단점\n- 신버전과 구버전이 동시에 존재하기 때문에 버전관리가 까다롭다.\n\n# 결론\n흥미로운 이름의 배포전략이 존재했고, <br/>\n모놀리식에서 마이크로서비스로 전환하면서 배포전략이 어떻게 변화했는지 알아보았습니다. <br/>\n\n## 운영 관점에서 느낀 주관적인 생각과 궁금증\n- 시간을 내어서 AWS 를 이용해 Blue Green 배포를 직접 진행해 보겠습니다. (나중에) <br/>\n- 도메인별 전략에 따라, 전략이 다를것 같습니다. <br/>\n- 결제 도메인의 경우는 어떤 전략 방식이 나을까 ? <br/>\n\n## 참고자료\n- https://hudi.blog/zero-downtime-deployment/\n- https://loosie.tistory.com/781"}]}},"pageContext":{}},"staticQueryHashes":[],"slicesMap":{}}