{"componentChunkName":"component---src-templates-post-jsx","path":"/architecture/","result":{"data":{"site":{"siteMetadata":{"title":"hyungkishin.blog"}},"markdownRemark":{"id":"3c1cc0a1-e646-5b0c-a212-7785bb4bb6e6","excerpt":"들어가며 loopers Round1 을 진행하며 고민한 흔적을 남깁니다. 정신을 차리고 보니, 어느새 코드보다. 설계에 더 많은 시간을 쏟게 되는것 같습니다. 자연스럽게 설계의 본질이 무었인지 회고해보았습니다. 설계의 본질에 대해서 코드는 변경을 감당하기 위한 계약 이다. 설계는 변경 비용을 어디에 지불할지 정하는 일이다. 우리는 항상 비용을 지불한다. …","html":"<h2>들어가며</h2>\n<p>loopers Round1 을 진행하며 고민한 흔적을 남깁니다.</p>\n<p>정신을 차리고 보니, 어느새 코드보다. 설계에 더 많은 시간을 쏟게 되는것 같습니다.</p>\n<blockquote>\n<p>자연스럽게 설계의 본질이 무었인지 회고해보았습니다.</p>\n</blockquote>\n<h2>설계의 본질에 대해서</h2>\n<blockquote>\n<p>코드는 변경을 감당하기 위한 계약 이다.<br>\n설계는 변경 비용을 어디에 지불할지 정하는 일이다.</p>\n</blockquote>\n<p>우리는 항상 비용을 지불한다.</p>\n<ul>\n<li>신규 입사자 진입장벽 을 낮추기 위한 노력은, <strong>이해 비용</strong>을 줄이는 선택이고.</li>\n<li>확장성 을 높이자니, <strong>미래 변경 비용</strong>을 줄이는 선택을 하게된다.</li>\n<li>생산성 을 높이려면, <strong>현재 구현 비용</strong>을 줄이는 선택 (대신 미래에 비용 증가가 발생한다.)</li>\n</ul>\n<p>그러다 결론을 내렸다.\n설계는 “아름다움”혹은 \"깎는 영역\" 이라기 보단\n<strong>비용 을 어느 상황에 지불할지에 대한 판단</strong> 으로.</p>\n<blockquote>\n<p>정답이랄 께 없지만, 조직에 소속되어 일을 하다보면.\n그 상황에 맞는 설계가 존재하고, 트레이드 오프를 제안할 수 있게된다.</p>\n<p>적절한 판단은 역시, 직접 부딪혀보는 경험치가 있어야한다.</p>\n</blockquote>\n<hr>\n<h2>Round1 현재 환경에서 매몰 비용을 치루게 된 사연</h2>\n<ul>\n<li>Redis 있지</li>\n<li>Kafka 있지</li>\n<li>TPS 모르지</li>\n<li>그러다보니,서비스 규모 예상안되지</li>\n<li>도메인 복잡도 모르지</li>\n</ul>\n<p>일부러 모호한 환경에서의 기획의도일까... 그럴 가능성이 높다고 본다..</p>\n<blockquote>\n<p>그래서 너무 좋은 기회인것 같다.\n\"불확실한 환경에서 설계 판단 연습\" 이랄까.\n항상 들어간 회사는 이미 시작된 서비스 였고,\n그러다 보니. 극 초기 의 상황을 몰랐다.</p>\n</blockquote>\n<p>스스로 겪어온 회사에서의 상황은 통상 아래와 같았다.</p>\n<ul>\n<li>평상시 TPS 50~300</li>\n<li>특정 시간대 5배 튀는 날 존재 할수도, 안할수도 있으며,</li>\n<li>요구사항은 계속 바뀐다</li>\n</ul>\n<blockquote>\n<p>그리고 또다시 결론을 내렸다.</p>\n<p><strong>좋은 땅을 가정하지 않는다.</strong></p>\n</blockquote>\n<hr>\n<h2>의존성 방향에 대해서, 왜 이렇게 가져가는가?</h2>\n<p>현재 의존성 구조:</p>\n<ul>\n<li>\n<p>interfaces → application → domain</p>\n</li>\n<li>\n<p>infrastructure → domain</p>\n</li>\n</ul>\n<p>지켜야 할 의존 방향</p>\n<ul>\n<li>의존성은 항상 안쪽(도메인)을 향한다</li>\n<li>도메인은 외부 기술에 의존하지 않는다</li>\n</ul>\n<p>처음엔 왜 이렇게 되었을까 라고 생각하기보단.\n창피하게도, 패턴으로 외우기 바빴다.</p>\n<p>지금보니, 이건 <strong>복잡성을 효율적으로 관리하기 위해 세워진 전략</strong> 중 하나인것으로 보인다.</p>\n<blockquote>\n<p>그러면, 앞서 말한 <strong>여러 전략중 하나</strong> 가 있듯이.\n복잡성도 여러 종류가 있을까 ?</p>\n</blockquote>\n<hr>\n<h2>복잡성도 두 종류</h2>\n<ol>\n<li><strong>본질적 복잡성</strong> — 비즈니스 규칙</li>\n<li><strong>우발적 복잡성</strong> — 프레임워크, DB, 네트워크</li>\n</ol>\n<p>우발적 복잡성을 바깥으로 밀어내고<br>\n본질적 복잡성만 중앙에 남기는 방식이 헥사고날 방식이였다.</p>\n<p>변경에 취약한 것이,\n안정적인 것에 의존해야 한다는 점이다.</p>\n<p>그래야 변경이 전파되지 않는다고 생각한다.</p>\n<blockquote>\n<p>어느순간 이걸 왜 고민하게 되었지 ? 라는 질문은 자연스레 해소되었다.\n결론적으로, 일을 효율적으로 하기 위해서는 여러방식이 있다고 생각한다.</p>\n<p>그런데 아직 가려운 부분은 해소가 안되었다.</p>\n<p>개발의 생태계는 프레임별로 간단하다면 간단하게,\n어렵다면 무진장 어렵게 생각 할 수 있다.</p>\n<p>그래서 보통 저마다의 상황이 있어, 더 나은 선택을 위함이지.\n이게 정답입니다 ! 라고 함부로 말하기 어려운 영역인것 같다.</p>\n<p>그럼 내 상황에서, 생각해보자.</p>\n<p>코드레벨, 구조</p>\n<p>누굴 위해서지 ?</p>\n</blockquote>\n<hr>\n<h2>“누굴 위한 코드인가?”</h2>\n<p>지금까지의 경험으로는, 우리는 비용을 어디에 두는가?\n부터 시작했었다.</p>\n<ul>\n<li>\n<p>도메인 보호 중심 설계의 경우, 본질적 복잡성을 보호하기 위해서요.</p>\n</li>\n<li>\n<p>유스케이스 흐름 중심 설계의 경우, 실행 흐름을 제어하기 위해서요.</p>\n</li>\n</ul>\n<p>지금은 AI 시대에 살고있고, 흐름 구현은 AI가 잘한다.</p>\n<p>그런데, 경계 정의와 복잡성 관리 전략은 사람이 한다.</p>\n<blockquote>\n<p>AI 가 구현을 더 잘해. 그런데 통제는 해야해 저마다의 상황과 조직별,\n은탄환을 위해서지, 수학적으로 접근할 수 없다.</p>\n<p>하... 그럼 어디에나 던져놔도 살릴수 있는 설계는 없을까 ?</p>\n</blockquote>\n<hr>\n<h2>“어디에 던져놔도 살릴 수 있는 설계” 란 무엇인가?</h2>\n<p>사이드 프로젝트, 토이프로젝트 지금껏 왜 망했었나 ?\n규모를 가정하고 정답처럼 생각했다.</p>\n<blockquote>\n<p>빅테크의 상황을 가정하지 않는다.\n대신 진흙뻘에서도 무너지지 않는 구조를 만든다.</p>\n</blockquote>\n<p>그 조건은 다음과 같다고 본다.</p>\n<ul>\n<li>도메인은 기술에 오염되지 않는다.</li>\n<li>트랜잭션 경계는 UseCase에 있다.</li>\n<li>외부 시스템(Redis, Kafka)은 Port 뒤에 둔다.</li>\n<li>처음부터 이벤트를 쓰지 않는다.</li>\n<li>하지만 이벤트를 못 쓰게 만들지도 않는다.</li>\n</ul>\n<blockquote>\n<p>미리 나누지 않되, 대신 나눌 수 없게 만들지 않는다.</p>\n<p>이게 어려운 영역이고 \"킥\" 이라면 킥인가 생각이 들 정도이다.</p>\n<p>그럼 어느때 설계가 무너지고 버그가 투성인 코드로 자라게 될까 ?\n애초에 접근이 틀린것일지도 모른다.</p>\n</blockquote>\n<hr>\n<h2>설계 위반 vs 버그</h2>\n<ul>\n<li>버그는 테스트가 잡는다.</li>\n<li>설계 위반의 경우, 테스트가 못 잡을 수 있다.</li>\n<li>설계 위반은 “나쁜 관습”을 퍼뜨린다.</li>\n<li>그 관습은 미래 변경 비용을 폭발시킨다.</li>\n</ul>\n<p>다시 정리하면, 설계 위반은 지금 당장 고장 나지 않는다.</p>\n<p>다만.. \"미래의 버그 확률을 구조적으로 증가시키는 행위\" 로 생각했다.</p>\n<p>강제 수준은 다음과 같다.</p>\n<table>\n<thead>\n<tr>\n<th>수준</th>\n<th>방법</th>\n<th>강제력</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>0</td>\n<td>없음</td>\n<td>없음</td>\n</tr>\n<tr>\n<td>1</td>\n<td>주석</td>\n<td>약함</td>\n</tr>\n<tr>\n<td>2</td>\n<td>코드 리뷰</td>\n<td>약함</td>\n</tr>\n<tr>\n<td>3</td>\n<td>ArchUnit</td>\n<td>테스트 타임</td>\n</tr>\n<tr>\n<td>4</td>\n<td>멀티모듈 + internal</td>\n<td>컴파일 타임</td>\n</tr>\n</tbody>\n</table>\n<p>가능하면 3 이상으로 끌어올린다.</p>\n<blockquote>\n<p>그럼 처음으로 돌아와서, Round1 인 지금시점에.\n처음 고민이였던, 복합적인 고민은.</p>\n<p>지금 당장 분리해야하나 ? 에 대해서 답을 내릴수 있을것 같다.</p>\n</blockquote>\n<hr>\n<h2>지금 당장 분리해야 하는가?</h2>\n<p>Nope.</p>\n<p>하지만 다음 신호가 오면 분리한다</p>\n<ul>\n<li>기능 하나 변경에 파일 n개 수정</li>\n<li>설명 비용 > 구현 비용</li>\n<li>테스트가 도메인이 아니라 JPA를 검증</li>\n<li>트랜잭션 경계가 도메인에 스며듦</li>\n</ul>\n<p>복잡도는 크기가 아니라<br>\n<strong>변경 비용의 증가 패턴</strong>으로 판단할래요.</p>\n<hr>\n<h2>설계 철학</h2>\n<p>감성 커머스 시스템은 다음을 우선한다.</p>\n<ol>\n<li>본질적 복잡성(비즈니스 규칙)을 보호한다.</li>\n<li>변경 비용이 전파되지 않도록 의존성을 설계한다.</li>\n<li>설계 위반은 자동화된 강제로 조기에 차단한다.</li>\n<li>기술 선택은 늦추되, 기술을 수용할 경계는 미리 만든다.</li>\n</ol>\n<hr>\n<h2>결론</h2>\n<p>설계의 본질은 이것이라고 생각합니다.</p>\n<blockquote>\n<p>시스템이 10배 커져도<br>\n핵심 비즈니스 규칙을 바꾸지 않고 확장할 수 있는가?</p>\n</blockquote>\n<p>아름다움을 위해 깎는 설계는 위험하다.<br>\n구조를 위해 비용을 배치하는 설계는 살아남는다.</p>\n<p>우리는 나주평야를 가정하지 않는다.<br>\n진흙뻘에서도 성을 쌓을 수 있어야 한다.</p>","frontmatter":{"title":"설계의 본질","date":"February 03, 2026","update":"February 03, 2026","tags":["설계","루퍼스"],"series":null},"fields":{"slug":"/architecture/"}},"seriesList":{"edges":[{"node":{"id":"157bc344-b416-5386-96b5-c8abcaaa04b1","fields":{"slug":"/deploy-strategy/"},"frontmatter":{"title":"배포전략"}}},{"node":{"id":"9ffe9bc1-affb-594e-835e-411f3a793a5a","fields":{"slug":"/cpu-bound-vs-io-bound/"},"frontmatter":{"title":"CPU Bound 와 IO Bound"}}},{"node":{"id":"57b20240-e6eb-5935-8501-3e6c67e74117","fields":{"slug":"/basic/"},"frontmatter":{"title":"코틀린의 현재와 미래"}}},{"node":{"id":"bb741bf1-7c1e-5b80-bb1a-14792a626e7f","fields":{"slug":"/coroutine/"},"frontmatter":{"title":"코 루틴"}}},{"node":{"id":"27dbdca2-3881-5505-8ab7-9ec45927fa02","fields":{"slug":"/basic/"},"frontmatter":{"title":"Redis"}}},{"node":{"id":"438d9589-dd16-5ed8-b45b-9f4a98acf02a","fields":{"slug":"/rag/"},"frontmatter":{"title":"Rag"}}},{"node":{"id":"949c21ae-8526-56ae-9f82-e1e9f517b13e","fields":{"slug":"/spring-ai/"},"frontmatter":{"title":"Ai. Spring AI 로 때워도 되나유? 1편"}}},{"node":{"id":"b9a90cce-fcd6-53ba-aa91-ef1e39152b15","fields":{"slug":"/phase1/"},"frontmatter":{"title":"🗞️ 한 달간의 뉴스 사이트 프론트 성능 최적화✨"}}},{"node":{"id":"1e90878c-3b63-5ee1-82dd-7c84ca638419","fields":{"slug":"/phase2/"},"frontmatter":{"title":"🏗️ AMP 페이지 개발"}}},{"node":{"id":"03510f8b-e65c-56a0-a96c-bc3935cc4600","fields":{"slug":"/phase3/"},"frontmatter":{"title":"퍼포먼스 최적화 를 향해 - 1부"}}},{"node":{"id":"720fdeea-fb60-5df7-a27a-47eba40a7300","fields":{"slug":"/phase4/"},"frontmatter":{"title":"퍼포먼스 최적화 를 향해 - 2부"}}},{"node":{"id":"50b5fb3c-da1f-5275-9401-02e0413fdf4e","fields":{"slug":"/resume/"},"frontmatter":{"title":"이력서"}}},{"node":{"id":"3c1cc0a1-e646-5b0c-a212-7785bb4bb6e6","fields":{"slug":"/architecture/"},"frontmatter":{"title":"설계의 본질"}}}]},"previous":{"fields":{"slug":"/resume/"},"frontmatter":{"title":"이력서"}},"next":null},"pageContext":{"id":"3c1cc0a1-e646-5b0c-a212-7785bb4bb6e6","series":null,"previousPostId":"50b5fb3c-da1f-5275-9401-02e0413fdf4e","nextPostId":null}},"staticQueryHashes":[],"slicesMap":{}}